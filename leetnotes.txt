https://docs.google.com/forms/d/e/1FAIpQLSeFOGWLCmQcJCNoZX23CZfS-oabFzllPmHCTGGyxwokIJVGUA/formResponse
Things to do: lookup list and priority_queue
158: Read n characters given read4 II - call multiple times - first read from internal buffer, then file, output extra chars read to internal buffer so that it can be read from next call
656: Coin path: Given an array A (index starts at 1) consisting of N integers: A1, A2, ..., AN and an integer B. The integer B denotes that from any place (suppose the index is i) in the array A, you can jump to any one of the place in the array A indexed i+1, i+2, …, i+B if this place can be jumped to. Also, if you step on the index i, you have to pay Ai coins. If Ai is -1, it means you can’t jump to the place indexed i in the array. Now, you start from the place indexed 1 in the array A, and your aim is to reach the place indexed N using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed N using minimum coins. If there are multiple paths with the same cost, return the lexicographically smallest such path.If it's not possible to reach the place indexed N then you need to return an empty array. Input: [1,2,4,-1,2], 2 Output: [1,3,5] - O(nb) solution is obvious. Next is slightly better - for each index starting from the last, pick the smallest node reachable so far i.e.  for i in range n-2 to 0, pick 'whaterver' such that min(A[i] + whatever) is minimized, where whatever is from the next i+B places - in that way, you'll go from i to end in cheapest possible path. To pick smallest node reachable, you can try maintaining a priority queue. - invariant is to maintain the queue with relevant elements i.e. next i+B elements <https://gist.github.com/andmej/0832b2677e8c7ccddea84d6a9721f35a> <https://www.snip2code.com/Snippet/3135728/O(n)-solution-for-problem-656---Coin-Pat/> - with O(nB) approach, you would've tried all next B nodes, here you're just taking the min out of those B nodes. And hence this seems to be similar to Djikstra - Create a graph with all int as Node and vertices from that node which node can be jumped. and value of the jumping node as a weight of the vertices. Now find the min path from start node to end node.
644: Maximum Average Subarray II - Given an array consisting of n integers, find the contiguous subarray whose length is greater than or equal to k that has the maximum average value. And you need to output the maximum average value. - binary search on min possible avg. value and max possible avg. value. If mid avg. exists, set low = mid and check for higher avg. value. Then trick is to find if there is a continuous subarray of size >= k whose avg. value is atleast mid. In other words, find max. avg. subarray of size atleast k. Similar to problem of finding max sum subarray of size atleast k - do it as follows: maintain a presum array (using Kadane's algo) which stores max sum 'upto and including' A[i] for all i. Then build a sliding window of length k and take ans = max(ans, sliding window sum, sliding window sum + maxpresum[i where is index before first ele of sliding window])
269: Alien Dictionary - given words in lexicographical ordering, find out the correct order of letters - create graph and do topological sort
308: 2D Range sum with updates
358: Rearrange String k Distance Apart - Given a non-empty string str and an integer k, rearrange the string such that the same characters are at least distance k from each other. All input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string. sort and store by frequency. append k different characters based on the above, then sort again. This is because you don't want to insert same chars again, a case like aaaabbbcc will fail -> abababacc, while on the other hand, you can't insert c anywhere you want in the middle, else aaaabbcc will fail abcabcaa, we need ababacac - so after k different chars, you will need to sort remaining chars based on frequency again. the old chars will have k gap minimum - the first one will again appear first and second behind first as 1 unit has been removed from each and distance from first to this new first is atleast k - at the end you might have more chars of same type to fill than k, in which case it is not possible. <https://hackinghorse.blogspot.com/2016/08/algorithm-rearrange-string-k-distance.html>
683: K Empty slots: There is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then. Given an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day. For example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N.Also given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming. If there isn’t such day, output -1. Example 1: Input: flowers: [1,3,2] k: 1 Output: 2 - soln: O(nlogn): Split range into intervals based on when the flowers are added, when you add a new number with lowerbound into the range array, you will only disturb that relevant interval, check if it forms k empty slots, if yes, return, else continue; O(n): maintain an array dp where dp[i] indicates on which day flower i blooms. We need to find dp[left], dp[left+k] such that all dp[left+j] in between are >=dp[left] and <=dp[left]
727: Minimum window subsequence - Given strings S and T, find the minimum (contiguous) substring W of S, so that T is a subsequence of W. If there is no such window in S that covers all characters in T, return the empty string "". If there are multiple such minimum-length windows, return the one with the left-most starting index. Input:  S = "abcdebdde", T = "bde" Output: "bcde" Explanation: "bcde" is the answer because it occurs before "bdde" which has the same length. "deb" is not a smaller window because the elements of T in the window must occur in order. - Intuition: my first thoughts were maintain info for when a particular b in S would be 1st b in T, 2nd b in T, etc. (in case of repeats in T) like maintain, what is the length of the shortest sequence if this b in S was the second b in T, or was the third b in T, etc. - wastes a lot of space and tough to deal with. Instead deal with it in order, i.e. process for each j in T in order. Consider sequence completed up until that jth character - ie. you will have info of shortest sequence which contains all chars until j-1 th. - use this to slide through S for this j in T. <http://massivealgorithms.blogspot.com/2018/05/leetcode-727-minimum-window-subsequence.html> - very elegant use of 'last'. - you only need two |S| sized arrays for this. Main Takeaway: Introducing order on the problem and processing in sequence takes out a lot of complexity
291: Word Pattern II: Another one of those try all possible combinations, backtracking problems <https://www.programcreek.com/2014/07/leetcode-word-pattern-ii-java/>
660: Remove 9: start from integer 1, remove any integer that containts 9 such as 9,19,91,etc. you will have sequence 1,2,3,..8,10,11,.. Given positive integer n, return the n-th integer after removing. If you remove all the 9s from a sequence of numbers in base 10, then you end up with a sequence in base 9. So all we have to do is convert n in base 10, to base 9 and return that. 1-1,2-2,3-3,4-4,5-5,6-6,7-7,8-8,9-10,10-11,12-13,..17-18,18-20,19-21,.. Seems to happen with a base which is one lower than given base. Basically, you're traversing through all the numbers in base 9 too, but since you're not allowed to use 9, you end up using the next number.
527: Word Abbreviation: Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below. 1) Begin with the first character and then the number of characters abbreviated, which followed by the last character. 2) If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words. 3) If the abbreviation doesn't make the word shorter, then keep it as original. - make abbreviation for each word. Then check each word, if there are some strings which have same abbreviation with it, increase the prefix - do with while(true) if any abb[j] = abb[i], then abb[j] needs to be changed - where j > i; i.e. for j, start with a greater length prefix (initially, for every string, prefix is just first letter)
471: Encode String with Shortest Length: "abbbabbbcabbbabbbc" "2[2[abbb]c]" dp[i][j] - between i and j maintain shortest possible.  if (l < 4) dp[i][j] = substr; for each i,j check if ik + kj is shorter, make that current. then check for repeat in i,j substring for k length where 0<k<l, if yes, then can abbreviate as dp[i][j] = 2[ab]
272: Closest BST value II: return 'k' closest values in BST given a target t; one approach is to inorder traversal, find element closest to t and use two pointer. Other is to implement two functions getPred(n), getSucc(n) which get predecessor and successor of given node. this is basically like stateless inorder traversal (except that you're storing state on the stack explicitly, so that you can continue from there in the next call) - compare getPred(n) and getSucc(n) results to choose which will be the next amongst k values and then update stack appropriately.