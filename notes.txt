ajay somani's notes on TC
Modular exponentiation and modular multiplication
Concept is quite interesting
modexp - multiply the base by itself, then multiply earlier product with itself, etc. if odd, multiply by base.
modmul - multiply by two, then multiply earlier product with itself
if odd, add in final step.
problems may involve matrix exponentiation - do it on matrix ops now

Some facts on euler's totient function from TC tutorials again
For prime p, for phi(a*p) or phi(a^p), etc.

1 TEST - Test
2 PRIME1 - Primality square root bound - one of the factors to be <= (sqrt N) - two sieves - one up until sqrt(largest number), use this to eliminate numbers within given range which is second sieve - segmented sieve - PRINT is similar which I've done
3 ONP - Reverse Polish Notation - look at complete input file - don't assume things
4 FCTRL - Print trailing zeroes of factorial of number - have to count even numbers and number of multiples of 'powers of 5' - powers of 5 because, eg: 25 - 5*5, one extra 5 - product of these give rise to zeros - since in a given range, number of even numbers is greater than number of 5's, counting the number of 5's is enough - have to look at optimizing logic like that to not get TLE
5 FCTRL2 - Big Integer problem - 100! - the number of digits in a number n is log(n) - number of digits in n! is log(n!) = log(n) + log(n-1) + ... - approximation of factorials are calculated using Stirling's approximation which is not needed here
6 CMPLS - Lagrangian interpolation, Lagrangian polynomials - complete the sequence - method of successive differences, forward differences table this should come to mind when sequence is continuous i.e. for f(i), f(i+1), f(i+2), etc. given in order cannot use if f(i), f(i+5), f(i+x), etc. are given
7 ADDREV - <algorithm> has reverse()
8 TOANDFRO - string ordering and pattern
9 CMEXPR - remove unneeded parantheses - accessing array elements out of bounds need not give segfault - may give random values - use stacks for detecting open brace, close brace - check all input test cases and even more because they might not cover everything - the approach was to consider each brace pair at a time for each brace pair, consider a list of curoperators (bear in mind that there can be more than one) for each brace pair, find the prevoperator and nextoperator if it exists check if the conditions are satisfied for each element in the list of curoperators only then remove the braces - can finish in one pass
10 JULKA - big numbers - take care of variables which are being reused
11 NSTEPS - pattern identification
12 SAMER08F - count squares within squares - sometimes formula might work better than loops - derive formula from loops if possible - if time limit is strict it will be needed
13 FASHION - sort vs. using something like heap - which is better to use - see number of operations and complexity - number of insertions, number of elements, how they will be used, etc.
14 CANDY - nothing touch
15 CANTON - pattern identification
16 COINS - easy dp - find optimal substructure - try catch for bad alloc in dict for dp - if it is full, can't add to dict, have to calculate - also maintain global dict if same dict can be reused for different test cases
17 LASTDIG - last digit of a^b, hence a^b mod 10 which is Modular Exponentiation
18 HANGOVER - floating ops - don't approximate unecessarily - float = 1.0f - look at this problem for floating point comparators
19 PERMUT2 - forgot to use delete[], cost 1 SIGSEGV - SIGABRT caused by problems with memory allocation
20 CANDY3 - simple problems may have huge test cases
21 EIGHTS - find kth number whose cube ends with 888 - find pattern, turns out to be AP - I didn't spot that - cannot increment counter and keep count - will be too slow - hence set digits of answer in an array, directly based on known pattern
22 AE00 - how many rectangles can be formed with unit squares - try to simplify the math even though it may take time this will lead to faster solutions - underflow, subtraction, unsigned numbers
23 ABSYS - string processing
24 AP2 - see if some values can go -ve while using unsigned numbers - d in AP might be negative even if all terms in AP are positive
25 ACODE - single scan DP - number of ways in which string can be decoded - I was considering c[0] <= 2 and c[1] <= 6 what I wanted was c[01] <= 26 for what I was doing, 17 doesn't pass - instead of recursion with function calls for dp, better is single scan left to right dp - look for such methods in string questions - d[i] = d[i-1], if d[i] and d[i-1] < 26, then, d[i] += d[i-2] because d[i-1]d[i] can be read together or one by one - string.erase(index, num of characters to erase)
26 ACPC10A - find if AP or GP, give next number in sequence - if problem is easy, then it is about handling all edge cases
27 STPAR - stacks, parade vehicle ordering
28 BISHOPS - number of non-threatening bishops on 'large' chessboard - identify pattern problem
29 ARMY - Godzilla vs. Mecha - min_heap using pq - priority_queue from <queue>
30 TRICOUNT - Triangle within triangle - count them - oeis.org - enter few terms of series, get formula - which is easier than deriving formula yourself
31 STAMPS - priority_queue - look at how to implement both min_heap and max_heap
32 GUESSING - online game - the actual game is to find an optimal sequence of guesses so that you get to the correct number as soon as possible - at each guess you get some information in return which you can use to formulate next guess - GUESSLNK is tougher - yet to try
33 JAVAC - string transform - java to c++ identifier and vice versa, if none, report error
34 OFFSIDE - detect if player is offside or not - read constraints carefully and direct code 
35 FENCE1 - floating point op - double format specifier is %lf
36 NGM - Turn taking game - integer given on the table - subtract any non zero digit from this number on the table - take turns, whoever writes 0 last wins - initially it looks like DP - best solution of subgame, then best solution within that subgame etc. - but the decrease in size of function at each iteration was not sufficient - hence runs out of stack space for recursing - in the end, Game Theory class example was sufficient - look at what move I make so that his move is forced - basically try to control the game if possible
37 EASYPROB - see pattern and code - had to submit text file with answer
38 EGYPIZZA - find minimum number of pizzas to order so that everyone gets their quantity from one pizza itself - check how to club the given fractions - 1/4, 1/2, 3/4 minimally, and code
39 NEG2 - numbers in base (-2) - look for pattern and code
40 MARBLES - Purely mathematical - bars and stars technique <http://www.mathsisfun.com/combinatorics/combinations-permutations.html> <https://en.wikipedia.org/wiki/Stars_and_bars_%28combinatorics%29> <https://www.statlect.com/mathematical-tools/combinations> <https://stackoverflow.com/questions/15301885/calculate-value-of-n-choose-k> --- look up Pascal triangle - DP method <https://en.wikipedia.org/wiki/Multiset> <https://www.quora.com/How-do-I-divide-a-given-number-into-a-given-number-of-parts-randomly-and-uniformly> - remember what is a multiset, n-1 C k-1 - no zero allowed, n+k-1 C k - with zero allowed formulas - fast way to calculate nCk = (n * (n-1Ck-1))/k - also (n+1 C k) = nCk + nCk-1
41 MAYA - numerical system of the Maya - string processing
42 PIGBANK - bottom up DP - if algo feels wrong - like you feel that there are too many corner cases, then it mostly is wrong - for eg. top down needs too many edge case handling here - also, in memo table for DP, what is chosen as key, what is value, are there duplicate keys possible - in this case it is two coins of same weight, then value should be one with lower value, because problem is about finding minimum amount of money that must be there in piggybank given that it's weight is so much and weights of individual coins are given - top down feels like there are so many possibilites, hence intractable - bottom up approach is, for each weight starting from min value, add the minimum weight coin, or the new coin - new coin may be added only at multiples of its weight - and only if it reduces the value - similar to bottom up knapsack - <https://www.geeksforgeeks.org/knapsack-problem/>
43 SBANK - large numbers sort - hence, use map - also keeps track of frequency
44 PIR - volume of pyramid - different formulas were giving different floating point answers - hence many WAs
45 CADYDIST - candy distribution - priority_queue
46 PT07Y - find if graph is tree - iterative DFS - check if you visit a node twice - then graph, else tree - also in neighbours, you will consider all nodes except parent node (node from which you visited the current node) - adjacency list to store graph - DFS approach is as follows - maintain a 'parent' for every node - from current node, after marking it as visited, while adding all neighbours to DFS stack, mark parent of neighbour as current node, unless the neighbour is parent of current node, in that case, mark parent as itself. Also maintain 'visit' field. If you've visited the node earlier and it's value != parent, that means, it is a cycle - because you're visiting the parent from a node other than its child, hence a cycle - note that almost any recursion can be converted to iteration notice that in recursion, the topmost element on the stack gets evaluated first. So if you're looking for an order in which to do iteration, go to the end of the list and come back to front. - can be done with BFS too - also, better than maintaining parent, etc. is to not add parent to DFS stack itself - so if you visit an already visited node, it necessarily means a cycle
47 PARTY - Within budget, find maximum party utility - greedy utility/price ratio does not work - kinda like knapsack - pick current object and decrease so much capacity and recurse or don't pick current object, don't decrease capacity and recurse - take max of both - if both give same utility, choose cheaper cost one - knapsack can be done in bottom up too - <https://www.geeksforgeeks.org/knapsack-problem/>
48 PT07Z - length of longest path in tree - double DFS - first DFS gives lower bound - if you're unsure about the approach, don't try to implement, wastes time, because edge cases won't be handled
49 SUMITR - sum of rows - DP - maintain for each column kind - shortcoding
50 UJ - Bigint, hence used Python - n (number of nephews) and d (number of CDs) - n^d ways
51 TWOSQRS - given integer n, decide if possible to represent as sum of two squares of integers - number theory <https://www.quora.com/How-do-I-check-if-a-number-can-be-expressed-as-x-raised-to-power-y> brute force with optimization - precompute all possible squares - do binary search in square space using two pointers method as they are an increasing sequence
52 HUBULLU - predict result of game if both players play optimally - try for n = 1, 2..7, then you'll be clear by then that first player wins no matter what
53 AGGRCOW - Awesome binary search - Assign cows to stalls so that minimum distance between two of them is maximum <https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/> Do a binary search on all possible minimum distances - start = lowest possible minimum distance - end = highest possible minimum distance - for a given distance, see if you can fit cows with that 'mid = (low+high)/2' minimum distance     -     low + (high-low)/2 for handling negative numbers too     -     another important thing is mid = low + (high-low)/2 might be equal to low due to rounding down, in which case, we will get stuck becuase low = mid --> low = low. Therefore if (mid == low), mid = mid + 1, hence ensure that you do not get stuck     -     reqd < ncows vs. reqd <= ncows, where to hand '=' case - in if or in else     -     for deciding low = mid or mid + 1 and high = mid or mid-1, see if mid will still be a part of the solution in next iteration, if yes, then it is = mid, else it is = mid-1 or = mid+1    -    I've used sets to ensure natural sort - also iterators to traverse - #include <iterator> gives prev() and next()
54 CPRMT - Twisted problem statement - just need to print common characters in ascending order - read through the question
55 BEENUMS - find if number is beenum - precompute and store in set - choose most appropriate data structure for fast inserts (in ascending order) and fast lookups
56 LASTDIG2 - modular exponentiation and mulmod - Ajay Somani Topcoder tute
57 GIRLSNBS - Minimum gender regularity - to calculate maximum number of students of same gender that appear together - that means for each boy how many girls, or vice versa, hence simple division with edge cases
58 BYTESM2 - Row Dynamic Programming - choose best choice at each row
59 NSYSTEM - Convert from one system to another and give answer in one system - most important thing in these problems is to minimize the number of conversions and do the required calculation in the simplest system
60 TRT - Treats for cows - DP with 2D grid - dict lookup is costlier than array lookup, hence if 1D/2D array is possible, go for that - also identify what is needed as part of key and what is not, in this case number of days wasn't required as it can be calculated from the number of items between begin and end - read Mimino's articles <https://www.quora.com/Are-there-any-good-resources-or-tutorials-for-dynamic-programming-DP-besides-the-TopCoder-tutorial> <https://www.quora.com/How-do-I-figure-out-how-to-iterate-over-the-parameters-and-write-bottom-up-solutions-to-dynamic-programming-related-problems> - Remember this and the cards problem as canonical examples - Find DP state with only relevant solutions - write a backtrack - recursive, which uses dict lookups preferably - then fill in case by case iterating in a proper order - sometimes it will be max(a1, a2), sometimes it will be max((a1,i)+(i,a2)) for all i between a1, a2 - which means 'for loop' - minimize the number of arguments to the recurse function, these arguments will be the indexes of the 2D grid - DP state should be represented by as few indexes/variables as possible - for eg. 1152, 1352, etc. can be DP states or 1...2, can encode both of them - longest common subsequence also in Mimino's answer
61 BEADS - Suffix array can be used <http://www.geeksforgeeks.org/suffix-array-set-1-introduction/> - also simple construct all strings of length n, sort, give answer can be used - I think I did consider only strings starting with smallest character, form substrings of length n from them and sort - even length n is not required, less than that, till wherever required is better
62 LABYR1 - another double DFS - challenging implementation
63 MIXTURES - variation of a problem from second Mimino's answer link question - the problem with just the above is some combinations are not considered for example, for {a,b,c,d}, the above considers (abc)(d) = (ab)(c)(d) and (a)(bc)(d) AND (a)(bcd) = (a)(bc)(d) and (a)(b)(cd) but it does not cover (ab)(cd) have to account for this similar for {a,b,c,d,e} luckily this can be done in one loop - the while(count) loop
64 BITMAP - a grid of 0's and 1's - find nearest 1 for each 0 - write that distance in that location - my approach - for each 1, go as far as possible - i.e. while it improves distance - stop if it doesn't - do not go further on a path if you don't improve the minimum distance - that means in first iteration, you will go on all paths reachable from that 1 because initial distance to each 0 reachable from that 1 would be initialized to INT_MAX
65 WORDS1 - <https://www.quora.com/How-do-I-solve-the-SPOJ-Play-on-Words-problem> - this should suffice - the first thing to look at is what is edge and what is vertex, 'consider both cases' and pick appropriately - here if end points of words are vertices, like for 'dance' de is a vertex, then it becomes a complex directed graph which will not be tractable and solved using simple conditions - here, only after we decide edges connect starting and ending letter, are we able to see that it is Euler path problem - see if you can use adjacency matrix if domain size is small - here all possible alphabets - 26*26 - in this case vertices are both end letters and edges connect starting and ending letters of word since we need to use all words, it means, find Euler path - path which uses all the edges - store incoming and outgoing vertices too - if all vertices have equal indegree and outdegree, then their overall degree (in degree + out degree for each vertex) is even or mod difference is zero - if exactly two vertices have outdegree - indegree = 1 and indegree - outdegree = 1, then one is start and the other is end - if not above two cases, then not possible to find Euler path - and for above two cases, check for connected graph using DFS - and choose start vertex for this DFS properly - in case of all even degrees, choose anyone with outdegree > 0 - in case of at most two odd degree, choose one with outdegree - indegree = 1 - also, for DFS, once you visit a node - i.e. a row index, for each j (column), make its entry 0 and add to DFS stack - no need to decrement count one by one - this can occur when words like dance, drive, etc. occur - same starting and ending letter, hence for i=d, j=e will be 2 - we don't need to traverse, we're just trying to see what vertices are reachable from start vertex
66 ARITH2 - simple calculations
67 PERMUT1 - <http://www.algorithmist.com/index.php/SPOJ_PERMUT1> - quite complex reasoning exists - but what I did was - look at constraint that n (1<=n<=12) and k (0<=k<=98) - hence 2D array dp - construct manually for n = 1, 2, 3 and 4 to see how to come up with solution - add existing inversions to previous inversions
68 ROADNET - graph with shortest path between two nodes given, find if two towns are neighours - this happens when there is no third town such that a path through it is shorter than direct shortest path which is given - Djikstra's algo - O(N^3) method maybe faster. Update of hops is critical. Djikstra's - have to consider entire graph from each vertex do a Djikstra run - you'll get shortest paths to all vertices - if the shortest path is reached in 0 (source vertex itself) or 1 hops, it means you're using direct path
69 POLEVAL - Evaluate a polynomial at a point - Use Horner's method. Synthetic division, Polynomial Reminder Theorem
70 DANGER - Josephus problem - have to find nearest two's power - log base 2 of a number is the best way - write down sequence for few iterations, identify pattern kind of problem
71 SUMFOUR - a+b+c+d = 0, 4 lists given. For all pairs a,b check if -(a+b) exists in unordered_map (with reserve keyword) which contains all pairs (c+d)
72 CHOCOLA - greedy - every vertical/horizontal cut has a cost, choose ordering of cuts so that cost is minimized - how to choose greedy vs. DP - most important, in choice betw. DP and greedy, see if greedy works in a DP problem try to come up with counter example that it doesn't - optimal substructure is key - because total number of cuts we need to make is same in whole problem we can change costs by ordering the costlier ones first - only across row and column - row after row or col after col makes no difference - when you apply costlier cut first, you ensure it is applied on less number of pieces - remove specific key,value from multimap <https://stackoverflow.com/questions/3952476/how-to-remove-a-specific-pair-from-a-c-multimap>
73 GSS1 - Range query - maximum sum subarray - Kadane is too slow - Hence Segment Trees - <https://www.youtube.com/watch?v=ZBHKZF5w4YU> <https://www.quora.com/What-is-the-approach-for-solving-GSS1-and-GSS3-on-SPOJ-using-segment-trees> - here querying also requires creation of nodes on the fly - updation of the four values - totalsum, maxnonemptyprefix, maxnonemptysuffix, maxnonemptysum is critical - (sizeof(inputarr)/sizeof(*inputarr)) is slick - One can be done in O(n), other in O(1), What if the number of query and updates are equal? Can we perform both the operations in O(log n) time once given the array? We can use a Segment Tree to do both operations in O(log n) time. - lazy propagation - update only when necessary - for range update, store tobeupdated number in lazy array which is same size as storage array, check that array before doing any 'getting information' operation
74 MINCOUNT - count number of moves required to invert triangle - found sequence on OEIS - important thing is to solve first few cases of the sequence properly
75 NY10A - count number of HHH, HTH, ... in a sequence of 40 tosses - maintain three strings, update, handling case by case - generalizing might be the real deal - does product DFA/NFA apply here?
76 QUADAREA - given 4 sides of quadrilateral such that sum of three is greater than the fourth, what is maximal area? - <https://math.stackexchange.com/questions/266783/geometric-argument-as-to-why-the-cyclic-quadrilateral-has-the-maximal-area> - <https://www.quora.com/Sphere-Online-Judge-SPOJ-In-the-problem-QUADAREA-why-does-my-program-give-a-wrong-answer-if-I-use-floats-but-a-correct-one-if-I-use-doubles>
77 CHICAGO - find path with highest probability of not getting caught - inverse of Djikstra - remember that Djikstra is about shortest distance from source to points not in the circle - it is not shortest distance from any point in current boundary to points not in the circle - also, in Djikstra, printing path means, store 'parent array' - instead of trying to update priority_queue, add everything to pq, but ignore visited <https://stackoverflow.com/questions/9209323/easiest-way-of-using-min-priority-queue-with-key-update-in-c>
78 MAXLN - Find max value of AB^2 + BC - Thales theorem, AB^2 + BC^2 = (2r)^2, because right angled - differentiate and find value - sometimes differentiate gives minima - have to reformulate optimization objective
79 WORDCNT - count number of words in longest continuous sequence of same length words - string handling and edge case handling - reading space separated strings - sstream
80 MFLAR10 - tell if tautogram or not - sentences with all words beginning with same case-insensitive letter
81 HPYNOS - sum of squares of digits - Happy Number if it sums to 1 - if it repeats in cycle, then not - upper bounding is important
82 AIBOHP - DP - find least number of characters to insert to make input string a palindrome - fill along diagonals, base case - 1 char at a time, 2 chars at a time - bottom up DP - two cases - depends on (i+1,column-1) or min((i,col-1),(i+1,col)) - first case if first and last equal, second if first != last - notice that proper separation - disjoint union ensures that locks are not needed - look at cpp for more details - alt is to use {strlen - LCS(str, revstr)} formula
83 AMR10G - find minimum difference between k heights out of given n - simple sort and maintain best so far - std::sort is quicker than qsort
84 HASHIT - straightforward hashing
85 FAVDICE - Coupon collector problem - remember approach - math
86 ACS - array operations - do row/column interchange and querying in O(n) time and complete array won't fit in memory - use arr[nrows] and arc[ncols] to keep track - you will need two more arrays to make everything O(1)
87 WILLITST - workout pattern till num=10 and then do - if power of 2, then stops, else no
88 SHPATH - textbook Djikstra - stop as soon as you hit destination node - again no need to update values in heap, just keep adding
89 SHOP - find shortest path in grid - modified Djikstra - no need to try to construct graph, instead directly use Djikstra on vertices - can also use BFS - in Djikstra's, see if you can stop after reaching destination vertex
90 ETF - Euler Totient Function - direct formula uses float ops, hence use modified method - <http://www.geeksforgeeks.org/eulers-totient-function/>
91 MRECAMAN - brute force sequence
92 ASSIST - find n th lucky number - like Josephus problem - sieve used for other purposes
93 TRGRID - traversing a grid - generating and classifying into cases is the key - reduce the grid to a small size after full traversals - in reduced grid size, dimensions can be (1,1), (1,2), (2,1), (2,2), ((1,2),other), (other,(1,2)) - now handle case by case - <http://xoptutorials.com/index.php/2017/01/01/spojtrgrid/>
94 ANARC05B - find maximum sum in two strictly increasing strings - can switch between strings at intersections (indices with same number) - linear DP - O(n+m) solution
95 ANARC09A - match the braces - DP was very slow, but perfectly working - had to use stack - couldn't really use 'only even number of {}'s' condition - other interesting O(n^2) DP solution <https://abitofcs.blogspot.in/2014/10/a-bit-of-string-balancing-spoj-anarc09a.html> - If you can't solve with grid method, try Mimino's classical approach and handle all cases - main thing is to recognize DP state - don't get caught up with the idea that two indices of string is the only possible state - in above link it was (index, number of open braces) - then look at current index and see what cases are possible
96 BASE - convert number from one base system to another system - interesting way to convert a base 10 number to any base - mod by base to get last digit in new base system, divide by base to reduce to new number and repeat
97 EBOXES - find total number of boxes on the table - create equation and solve
98 EDIST - find minimum number of insertions/deletions/replace needed to make two strings the same - 2D grid DP - similar to LCS - sometimes initialization may need to be done in a custom fashion - after base case is properly handled, everything will fall into place
99 BYECAKES - find least amount of ingredients to buy to make minimum integer number of cakes - kinda greedy - ratio approach - lot of edge cases - 0 0 0 0 2 3 4 5 was one hell of an edge case
100 INVCNT - calculate inversion count in given array - standard merge sort based solution and also Fenwick tree based solution (Binary Indexed Tree BIT) - look at problem file for details - key steps - normalizing data while maintaing order, processing from back to front to convert into Fenwick tree --> calculate prefix sum of index and update by adding 1 at that index problem - <https://notes.tweakblogs.net/blog/9835/fenwick-trees-demystified.html> for beautiful Fenwick tree explanation - no need of extra 0 for root in Fenwick tree - both Prefix sum and update in O(logn) without extra space - also read about bitmask since it was one of the tags - used in set enumeration problems - TSP using bitmask, N person, N task assignment problem - both can be done using bitmasks - see file for more info - see constraint on n - if it is less, that means, all sets can be enumerated --> bitmask - see 126 ASSIGN
101 CUBES - find all a^3 = b^3 + c^3 + d^3 where a>1, a<=100, brute force - dict and set problem - whenever brute force, think about dict/set
102 CSTREET - MST - used Kruskal's - Be careful in getparent - at the end, in line 44 - you have to change set of parent, not set of current - can also reset parents of all indices during traversal to actual parent, speeds up further getparents - Prim's - For Prim's, maintain visited list/set and cost list - both over vertices - cost list maintains cost of all edges in the cut - choose min of that i.e. cost of reaching vertices part of cut, but outside visited, from vertices part of cut, but already visited - initialize cost list to infinity, and on adding an edge to visited, update cost of all vertices which become a part of the cut
103 TOE1 - find if given state is valid position in a tic tac toe game or not - consider edge cases - read question that x always starts first
104 ABCDEF - find all possible sextuples - three on LHS, three on RHS in sorted array - binary search - brute force - map is not always good - when multiple inserts - better to sort at once - distance(it1, it2) from std::iterator gives number of elements between it1 and it2
105 HISTOGRA - calculate area of largest rectangle in a histogram - all nearest smaller values problem - stack based solution - D&C - using segment tree - O(n) vs. O(nlogn) - see problem file for more details - segment tree --> RMQ - range minimum query - important thing here is to understand why these are working - for stack based soln, one of the answers on Quora had an explanation on flipping the constraints  - like dual of LP - for any pair of indices i,j, maxarea(i,j) is constrained by min(i,j) - flip to find that for each index given height, till where can you extend boundaries - to left - to right - hence stack based - also can we manage in one pass? - D&C is easier to understand, again in a given range, find min - it extends till end of range on left and right side - recurse in left part and right part from given index - why does it work? you will consider height of all indices and stretch it to maximum possible on both left and right - hence all cases are considered - converting it to RMQ problem is the key step - min(i,j) is the key
106 PPATH - find smallest number of 'one digit at a time' changes from one 4 digit prime to another 4 digit prime both of which are given - sieve, create graph of primes, BFS
107 GLJIVE - Find cumulative sum starting from index 0, closest to 100 - cryptic way of stating the question
108 POUR1 - GCD, recursion - find minimum number of moves to make 'c' using containers 'a' and 'b' - pour, empty, transfer - linear diophantine equation - ax+by=c iff c % gcd(a,b) = 0 - other way to discuss feasibility is to look for cycles - see problem cpp - notice the 'difference' method of calculating GCD - keeping on subtracting the smaller number from bigger number, GCD won't change, but you will end up at the GCD - can solve using BFS also - see problem cpp - remember to check other way around, if possible - for example here there were two ways, pour from a to b OR pour from b to a - I did not consider both possibilities - Diophantine equations are important when a problem requires a solution in whole amounts - using only container 'a' and container 'b' - see if you can cast as Diophantine problem
109 ANARC09B - Find smallest number of rectangles to use to form a square - orientation of the tiles is to be the same - spoj toolkit was wrong - lcm/gcd
110 NOTATRI - given a series of numbers, find number of ways of picking three numbers from the sequence such that they don't form a triangle - binary search - sort - order doesn't matter, only combinations, not permutations - for every pair, find index of element with value > sum(a+b), everything to the right and this included, cannot form triangle - edge case - find leftmost such index
111 OLOLO - given a sequence of numbers, all numbers appear twice, except one - find that number - bitwise xor ^ operator - if 'twice'/'even number of times' occurs, think of using xor
112 STREETR - given sequence of trees, find minimum number that must be planted, so that distance between any two adjacent trees will be minimum - eg. 1 3 7 13 - 3 trees at 5, 9 and 11 - I did O(minDist*n) scan which is slow - better is to find gcd of distances - gcd n numbers - sort and find for each pair - gcd can only decrease - gcd(smallest two nos.) is best upper bound
113 PHONELST - given phone numbers, say if they are prefix free - trie based solution - related to huffman coding
114 ROOTCIPH - given a,b,c in x^3+ax^2+bx+c, the roots of which are the relative coordinates of plane, find square of distance - <http://codeinblood.blogspot.in/2017/01/decipher-spoj-problem-solution.html> - <http://forums.xkcd.com/viewtopic.php?t=15382> - sum of roots, product of roots - relation of them with coefficients of the polynomial
115 BLINNET - Kruskal's - borrowed template from earlier Kruskal's code - changed getparent to point to which set it belongs to using recursion - optimized for dist a-b = dist b-a, hence ignore later edges
116 PQUEUE - printer prints jobs according to priority - 6 0 - 6 jobs, 0th is mine - 1 1 9 1 1 1 - first job taken from queue, if highest priority print, else push to 'end of' queue, hence in this case time taken is 5 seconds - so maintain two priority queues - one for actual priority, other for indices - similar to two stack approach in some other problems - custom comparator for priority queue
117 SILVER - Given a rod of length n, divide it into minimum number of parts such that you can generate a rod of each length from 1 to number n. For given n, 2^m<= n < 2^(m+1) , number of cuts will be m and hence numbers of parts will be m+1. In present case n=7 lies in the range [4,8), so number of cuts(divide/break) = 2 - think of it as binary number representation - 0 - you don't give, 1 you give - least number of bits needed to represent a number - brilliant
118 PON - Prime or not - Implement Primality test - Miller Rabin from Cryptographic_Musings repo - no need of perfect powers test - C++ may give overflow, hence use unsigned long long
119 CLONE - given a set of strings, count number of occurences of each - dict solution
120 LENGFACT - length of n! - <https://www.geeksforgeeks.org/count-digits-factorial-set-2/> - formula based - Kamenetsky's formula
121 CRSCNTRY - cryptic problem statement - turned out to be vanilla Longest Common Subsequence - LCS - bottom up DP - important to decipher problem statement - read problem statement for this on SPOJ
122 MKLABELS - find number of possible labeled trees for given n where n is number of nodes - pattern can be found pow(n, n-2) - OEIS can also be used <http://oeis.org/search?q=1%2C3%2C16%2C125&language=english&go=Search>
123 ROCK - find total length of rock that can be sold after breaking up the rock in the best possible way - sweet to be greater than sour - eg. for 100110001010001 - 10011 101 1 = 5+3+1 = 9 length - two ways to solve this - Matrix Chain Multiplication MCX - all possible combinations of k - which is what I did - O(n^3) - <https://www.quora.com/How-do-I-solve-the-sweet-and-sour-rock-program-in-SPOJ> - the other is using just one array dp - very elegant - <http://artofcompetitiveprogramming.blogspot.in/2016/01/spoj-sweet-and-sour-rock.html> <https://github.com/georgejsh/codeandsolutions/blob/master/rock.c> - here - so the problem b[i] can be solved as b[i] =max( b[i-1]  , b[j-1] + i-j+1)  for each j where the segment from j to i has more sweet rock than sour (j<i)
124 BINSTIRL - <https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind> - find parity - i.e. ans%2
125 SQRBR - What is the number of proper bracket expressions (num open = num close and valid) in length 2n, given that you need '{' compulsarily at s1<s2<s3..<sk positions - DP - bottom up - do not get stuck up with grid where i,j mean indices of string - it may be grid where i,j mean something else - here let count(i,j) be the number of valid ways of filling the first i positions such that there are j more brackets of type '{' than of type '}' - count(0,1) = 1, build from there - count(0,i) = 0 for i>1 - recurrence for i>0 is count(i,0) = count(i-1,1), count(i,j) = count(i-1,j-1) + count(i-1,j+1) for j>0 - but if you have to enforce '{' at position i, then, count(i,0) = 0 and count(i,j) = count(i-1,j-1) for j>0 - I was stuck up with grid index thinking - if it is too hard to formulate, then it means, grid string index meaning of the problem is wrong way to think about it, move on to try to find another dp state - one of them will most likely still be index of string, but the other variable in the state may mean something else - <https://www.quora.com/How-to-solve-square-brackets-problem-on-SPOJ-SPOJ-SQRBR> - notice that we get answer at count(2n, 0) - subproblems are disjoint - i.e. count(i-1, j-1) and count(i-1, j+1) don't enumerate the same cases and hence can be just summed over like we don't want AUB = A+B-(AXnB) - index 'i' is monotonically increasing, so fill row wise - very important to get right DP state - (index, number of valid ways '{' j more than '}')
126 ASSIGN - given n classes, n student preferences, assign 1 student to 1 class within given student preferences - find number of ways to do this - start with backtrack (systematic way to brute force) - because we need faster, use DP with two states (mask, i) and bitmask - mask indicates which students have been allocated, i indicates classes 0 to i-1 have been dealt with - countways(mask, i) = countways(mask, i+1) + sum(countways(mask|(1<<j), i+1) for each j which can do task i) - but i can be calculated as sum of set bits in mask as we cannot do countways(mask, i+1) i.e. move on without assigning because we need 1-1 map - hence dp state depends on just mask - we need bottom up DP - derive it from above top down DP - notice order which they have to be filled - reverse order - <https://www.hackerearth.com/practice/algorithms/dynamic-programming/bit-masking/tutorial/> - <http://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/> - see code file - see 100 INVCNT - intuition for DP comes from backtrack solution in this case - remember a few canonical DP states - TSP, assignment problem - in TSP, we need two variables for state because relative ordering also matters - also min(ans, newans) vs. sum() - see cpp file
127 BABTWR - a,b,c - three dimensions of box given, you can rotate however you want, any number of boxes of given dimension are available, what is tallest stack of boxes you can build given that you can only stack one box on another if both of the non-height dimensions are lesser than the one on top of which you're stacking -related to Longest Increasing subsequence and box stacking problem - <https://www.geeksforgeeks.org/longest-increasing-subsequence/> - <http://code.cloudkaksha.org/algorithm/dynamic-programming/box-stacking-problem> - exploit sorted order, also be very careful on what to do with the values if duplicate keys can exist for a dict
128 GSS3 - GSS1 + update - for update, just set the leaf node appropriately and update upper nodes, lazy propagation is harder to implement
129 TOE2 - find out if valid end position of TicTacToe game or not - same as TOE1 except 1 case - draw - only when board is full - interesting <https://stackoverflow.com/questions/7466429/generate-a-list-of-all-unique-tic-tac-toe-boards>
130 SBETS - who wins the world cup - see the scores, team with 4 wins is the winner
131 MAJOR - if number transmitted > 1/2 the time, then it is successfully transmitted - print yes/no - Boyer Moore algorithm can also be used - <https://www.geeksforgeeks.org/majority-element/> - basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element
132 MATSUM - sum of elements in a matrix from (x1,y1) to (x2,y2) - 2D Fenwick tree - 2D Binary Indexed Tree, 2D BIT - update should also be supported - <https://github.com/stranger9811/spoj/blob/master/MATSUM.cpp> <https://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/> <https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/> <https://www.quora.com/How-do-I-implement-a-2D-binary-indexed-tree-for-range-update-and-range-query-operations> <https://www.quora.com/How-does-a-2D-segment-tree-work> <https://stackoverflow.com/questions/25121878/2d-segment-quad-tree-explanation-with-c> - segment tree can also be made 2D - called quad tree - 2D Fenwick tree is straightforward extension of Fenwick tree for a grid - each index of 1D Fenwick tree is now another Fenwick tree - indices can get pretty confusing, i.e. when to use >0, <n, <=n, etc. - also, to update (x,y) to val, you have to find actual existing value at (x,y) first - this is done by using (x+1,y+1), (x+1,y), (x,y+1), (x,y) - then update with relevant value i.e. (val - (above sum)) - adding elements to tree is simply update - sum uses similar concepts for sum for grid indicated by (x1, y1), (x2, y2) - but remember to take (x2+1,y2+1)
133 BUGLIFE - in a graph, given edges, detect if homosexuality is evident - a bit of DFS with parent tracking and bipartite matching/graph coloring with two colors - first thought is that a cycle detection using DFS should be enough - but no, cycle is also fine if number of edges in cycles is even number of edges away - eg: 1-2-3-4-1 -- 1 M, 2 F, 3 M, 4 F - hence cycle is fine in this case
134 ANARC08B - Add two seven segment display numbers - simple string processing
135 TETRA - calulate radius of sphere inscribed in a tetrahedron, formula based - just remember to use double in these kind of formula based problems
136 BRCKTS - think segment trees automatically, if update and query - many of them - like always, what are the fields of segement tree node required is important to figure out - here leftunbalanced and right unbalanced was enough
137 DIV15 - out of given numbers, find maximum number possible which can be divided by 15, else print impossible - probably one of the toughest to handle edge cases- <https://apps.topcoder.com/forums//?module=Thread&threadID=567782&mc=30&view=threaded> - very important - 0. Count total digits, and count total digit modulo 3 --> remainder. - 1. Choose last digit, if there are any 0, use it, if there are any 5, use it as last digit, otherwise it is impossible. - 2. If remainder is 0, we're done, print all the digits from 9 to 0. - 3. If remainder is 1, try to substract with proper number, I guess maybe this is where I missed something, I thought that you could ignore all 0,3,6,9 digits, because substracting them would not change anything. - I will consider first trying to substract just one digit, any f 1's,4's or 7's. If there are none of these then - I will consider trying to substract two digits, combination of 2,5,8. in this order (2,2), (5,2), (5,5), (8,2), (8,5) or (8,8). - 4. If remainder is 2, do similar to step 3, with 1,4,7 replaced with 2,5,8. -- up to speed until - 'subtracting more than two digits is useless' - that was the critical insight - I consider removing numbers from either these two set of number (1,4,7) which are 1 in modulo 3 and (2,5,8) which are 2 in modulo 3. I guess you agree removing 0,3,6,9 will have no effects on remainder. - Removing three numbers either a,b,c from the first or A,B,C from second set: - if all 3 from the first set it will have no effect. if before removing you have X, after removing you have X-(a+b+c). Where (a+b+c)%3 == 0 since a%3, b%3, c%3 == 1. So (X-(a+b+c))%3 is still the same as X%3. - Taking one from the first set and two from the second set will have the same effect as taking just one from the second set. X-(a+B+C) = X-(1+2+2)%3 = X-2; - Taking two from the first set and one from the second set will have the same effect as just taking one from the first X-(a+b+C) = X-(1+1+2)%3 = X-1; - Taking all from the second set will have no effect with similar explanation as taking all from the first. - I am too lazy to think further, but basically since we are working with modulo 3, removing any n numbers, will have only 3 kinds of effects, either the same as adding 0, 1, or 2. - modulo effect
138 MICEMAZE - given time t and graph(v,e), and all mice from each cell escape to given dest in shortest path, how many mice escape within time t? - kinda like inverse of Djikstra - like, given dest, from what sources can you visit dest - also in Djikstra, remember, when you push to queue, you have to - add distances up to the parent node, because it is 'single source' - shortest path algo - you can't just push arr[i][j], do distances[i] + arr[i][j]
139 MISERMAN - line by line DP
140 DYZIO - count the number of cuts which have to be made in order to get to the shortest piece - 1 - cut (recurse) left and right, 0 - return - it is not depth of recursions, but it is number of cuts - hence it maybe greater than depth of recursions, if smallest piece is reached on the righter side - was slightly tough to understand the question
141 CNEASY - Output an integer - the minimum number of seconds that Christy needs to take all landmarks' photos - find max dist after sorting - take care of 360 - a[n-1] + a[0] also
142 GEOPROB - bigint geometry problem - a = (c-b)+(c-d) - enough if ratio remains the same I guess - <https://apps.topcoder.com/forums/;jsessionid=5FBC9D76176657EA4B331B6CE3FA3538?module=Thread&threadID=632397&start=0&mc=3#1061249>
143 GUESSTHE - given a sequence of 'YYNYY', etc., output minimum positive integer that satisfies all the clues, or -1 if there is no such number (i.e. some clue is violated or contradictory) - where each index indicates divisibility by that number - Y at 2 - divisibility by 2 - LCM problem - instead of the below for 'Y' case, we can do it together at the end - find lcm of all 'Y''s and later, together check if 'N''s divide it
144 BOMARBLE - number of marbles required to form a pentagon - OEIS saved the day again - they say that it's an easy patter/recurrence to spot - DP
145 SCAVHUNT - print route in correct order - STL maps
146 BOOKS1 - assign books to scribes such that overall time is reduced - similar to AGGRCOW, except process from the last and use 'high' instead of 'low' - also no need of if(mid==high) mid -= 1; because division will round down, not up - also sort(arr, arr+m) is causing problems no idea why - obviously it will cause problems, we're trying to assign books for given order, not for sorted order
147 SCPC11B - given location of petrol pumps, can we complete roundtrip? - sort and see if dist > 200 between two elements of array
148 MCOINS - given n coins, A and B to play, can remove 1, k or l coins only - who wins if A plays first? - I did using top-down DP, can convert to bottom-up DP easily
149 PT07X - find minimum vertex cover in tree - every tree is bipartite graph - can be solved in three methods - BPM max flow/Hopcroft Karp, DP, greedy - see cpp file for details - BPM - color with BFS using two colors - connect source to blacks, sink to whites, max flow - DP derived from greedy, find dp[i][0], dp[i][1] for each node - greedy - start from leaf nodes - add parent of leaves, for internal nodes, if any child is not in min vertex cover, add this current internal node - see POTHOLE, TAXI
150 JRIDE - standard Kadane's algorithm
151 SCUBADIV - given oxygen and nitrogen capacities, find least weight cylinders to take - similar to 0/1 Knapsack DP - initially thought that weight was part of dp state - that was a very silly thing to do - turns out index (of given tuple (oxygen,nitrogen,weight)) is part of the dp state - which is logical - sometimes if you just cross size limit of 3D array, it gives segfault
152 STONE - find centre of gravity (centroid) of given 2D polygon - centroid of polygon formula <https://math.stackexchange.com/questions/90463/how-can-i-calculate-the-centroid-of-polygon> - The centroid of a polygon is indeed its center of mass -- but the mass of a polygon is uniformly distributed over its surface, not only at the vertices. You're right that if the mass were split evenly among the vertices only, the centroid would be the arithmetic mean of the coordinates of the vertices. It just so happens that both definitions are equivalent (mass evenly distributed over the surface vs mass at the vertices only) for regular shapes like triangles and rectangles
153 CATM - adhoc - see if mouse can escape from two cats given initial position in rectangular grid - see if mouse lies on diagonal with cats (they should also be on diagonal) and lies in between the cats on the diagonal - then can't escape
154 ACT - given the complete order of who wins points in tennis match, find out who wins match - obviously last player to win point wins the match - just check last character - this holds unless there is rule which deducts game/set on winning points, which wasn't the case in this problem
155 POKER - given cards, tell what out of 10 hands you have (descending order) - cards input can be in any order, hence create order through sort or 'map', etc. then check conditions one by one  - Brian Bi's code
156 TWENDS - similar to TRT - now we need to print p where p is the maximum possible difference between the first player’s score and second player’s score when the second player uses the greedy strategy - now why is answer = (first player uses dp - second player uses greedy)? - why should first player use dp and hence why is maximal soln. for first player = max. difference between the two? - thing is if first player doesn't choose maximal soln., whatever he doesn't choose goes to second player, who does better and gap closes, hence difference decreases which is not what we want
157 ANARC08H - Josephus Problem recursive solution - both this general version and the power of 2 version - see DANGER - have standard solutions - this is kinda like DP - (n,d) = ((n-1,d) + d-1)%n + 1 - basically, solve for one less number n, then when you add n, somehow remove one number based on d, then what you have left is (n-1,d) - just adjust for offset now - solution is from (n-1,d) - <https://www.geeksforgeeks.org/josephus-problem-set-1-a-on-solution/> - that link shows top down, cpp file has bottom up
158 POTHOLE - maxflow - Edmond Karp - lot of learning - both algo and C++ - code adapted from: <https://en.wikibooks.org/wiki/Algorithm_Implementation/Graphs/Maximum_flow/Edmonds-Karp> - C++ adapted from:<http://marcodiiga.github.io/maximum-flow-bipartite-matching> - adjacencyListFrom adapted from:<https://www.quora.com/ACM-ICPC-How-do-you-implement-Edmonds-Karp-Algorithm-for-sparse-graphs-using-adjacency-lists> - Edmond Karp is better when number of edges is less O(VE^2) - Dinic is better when number of edges is more O(V^2E) - for sparseness, we use adjacency list - back edges in residual graph need to be taken care of in a clever way - we can tradeoff space or time - contains template for Edmond Karp maxflow - see PT07X
159 PRO - in 'n' days, there will be 't' numbers put into the box every day where 't' maybe different for each day, at the end of every day, remove the largest element and the smallest element, add up the differences for all the days - you may think two priority_queues may do the job, one max_heap, one min_heap, but use 'multiset' here it is better - have to perform operations only on one data structure and hence it is faster - sets are implemented as Binary Search Trees underneath, they could also be implemented using Hash tables - I still think you could do it using heaps, since there is always two elements in the box, we can keep removing without issues
160 MTILE - how many ways can we tile a 3xN grid with 2x1 tiles - bottom up DP consider all relevant cases - the important idea is that there can be two functions making up the recursion - T(n) = 3*T(n-2) + 2*F(n-3) and F(n) = T(n-1) + F(n-2)
161 FIBOSUM - sum of F(a) to F(b) given a and b where a <= b - use FastFib <https://www.nayuki.io/page/fast-fibonacci-algorithms> - in modular ops, be careful when negative numbers arise - have to do a '+ MOD' when such a case arises
162 RABBIT1 - look at FIBOSUM - sum to n terms of Fibonacci series is S(n) = F(n+2) - 1
163 FACEFRND - Find how many friend of friends - bool array
164 ORDERS - my initial technique was the following: given 0 1 2 0 1 - find rightmost smallest number - 0 at posn. 4 - make it INT_MAX and decrement count of everything to its right - so 0 1 2 M 0 - M will be 5 in final answer, next 0 1 2 M M - second M will be 4 - next M 0 1 M M - first M will be 3 in final answer and so on - we can use rangeMinQuery/heaps for this, but still worst case O(n^2) - better is: have a segment tree array with all 0's initially - it should support two ops: - find ith cell from left which contains a zero : - update the value of the ith cell from 0 to 1 - so take input array 0 1 2 0 1 and traverse from right to left - find 5-1 = 4th 0 in segment tree array - essentially, we assume that everything to left is sorted, only then we act - because of question - so if number in 5th position does 1 shift to the left, it means, it ends up in 4th position in final answer so it means initially, 4 was in 5th position so index of 5-1th zero is newarr[i] - update segment tree i.e. make that index 1 - next find 4-0 = 4th 0 in updated segment tree - this essentially means, leave out the just inserted 4, in the remaining indices, find where this element will go if left shifted given number of times - this has log(n) ops to find ith zero and log(n) ops to update given index to 1 - to find ith zero is one more tricky thing - look at rangeMinQuery below, basically divide and conquer can use Fenwick Tree also - <https://www.quora.com/What-are-the-ways-to-solve-this-spoj-problem-SPOJ-com-Problem-ORDERS> - <https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t/17504505>
165 RENT - standard job scheduling problem - given a list of start, end times and value for each item, find maximum value generating schedule - initial thought was it is like knapsack problem - sort jobs according to increasing order of finish times - now standard dp way of thinking is: two cases for each job - either include or don't - that can be made faster here - if we include certain jobs, certain others can't be included, those certain others are the ones whose times intersect with current job that is where sorting helps - O(n^2) - for each job - newarr[i] will store the best profit obtained 'including' that job and considering all preceding jobs - hence initialize it to profit(i) for all i - now, starting from left, for each job i, consider 0 to last non intersecting job - j's - for each j, and this current i, do newarr[i] = max(newarr[i], newarr[j]+profit[i]) - finally do a linear sweep of newarr to get max possible profit
166 FISHER - given a graph with edge costs and edge traversal times, find if source to dest is possible within given max time t - dp[vertices][time] stores cost(tolls) where dp[j][i] = min(dp[j][i], dp[k][i-time[k][j]] + tolls[k][j]) - similarities to: 1)Floyd-Warshall - there, outermostloop i is over 1 to n - shortest path including vertices 1 to i in iteration i - and in each iteration, iterate over all possible pairs - here too we do iterate over all possible pairs, but outermostloop is over all times 2)Subset Sum MAIN72 - there inner loop is for all possible sums upto desired sum, outerloop over all indices of array - store number of ways sum can be constructed in dp 3) Knapsack - there inner loop is over all weights, outerloop over indices of array, store maximum reward in dp - contrast all of these with RENT - job scheduling - also very important assumption is {i!=j => distance[i][j] !=0}, hence the subproblem size is guaranteed to be less than the original problem size, giving a finite recursion - see cpp file for Djikstra method - see ROADS - dfs with branch and bound method - notice the many constraints i.e. time is <100, cost <1000, etc. which should lead to the enumerate all [time], all [cost], etc. type of DP solution
167 FAKETSP - read input problem - scanf("%lf", &x) == 1
168 HEADSHOT - 000111 - shoot, rotate or equal - given that your opponent got 0, how would you maximize your 0 - basic probability
169 PARKET1 - Derive formula and code
170 ACPC10D - Tri-graph, cheapest cost path, row wise DP with a clever trick - notice the shit code I've written vs. the optimized code below - the thing is, the case for some paths is contained in previous paths due to the rightward directionality of the graph - the key is to spot that - this is way better than enumerating all possible cases from scratch
171 STABLEMP - <https://www.youtube.com/watch?v=GsBf3fJFpSw> <https://en.wikipedia.org/wiki/Stable_marriage_problem> men keep proposing to women until they're accepted and no man is left - women keep accepting as long as they get better match - the proposers get best match possible, acceptors get worst match possible - because proposers have entire set to choose from, acceptors have only limited choice
172 SAMER08G - simple problem
173 PFDEP - topological sort - DFS method with finish times - sort in descending order of finish times to get topological sort order - might help someday <https://stackoverflow.com/questions/20153488/topological-sort-using-dfs-without-recursion> - key is to remember to sort the adjacency list and visit the nodes in proper order - because it is mentioned that if there is no ordering between nodes i and j, print i first if it is lexicographically smaller
174 BENEFACT - double DFS on Tree - find diameter
175 GARDENAR - Geometry, formula based - given interior point - i.e. distances to interior point from all the three vertices of an equilateral triangle, find the area of the triangle - <http://www.gogeometry.com/problem/p103_equilateral_triangle_heron_area_elearning.htm> - <https://math.stackexchange.com/questions/329761/equilateral-triangle-geometric-problem> - can also use cosine law to write the formula easily, but solving may give errors
176 HEPNUM - easy enough - find if one base 17 number is <,>,= to other given two strings
177 ONEZERO - awesome BFS and State space and modular arithmetic problem - find smallest number containing only 0's and 1's in decimal representation which is a multiple of given number N - take numbers which are 0's and 1's, need to go to new numbers, in ascending order, do n*10+0, n*10+1,  1 -> 10,11   10->100,101  11->110,111 - notice the bfs queue order, generating permutations using queue instead of recursion - second point is modular arithmetic on division e.g. 356%8 = 4 like 3%8 = 3 --> 3*10+5 = 35%8 = 3 --> 3*10+6 = 36%8 = 4 as earlier - third point suppose the number you want is X, hence X mod N = 0, you'll only need to store N states - 0 to N-1 because if a number gives an already visited mod, you're cycling/making the number bigger, that branch of tree need not be explored further - this can be added to the optimization - fourth point you don't need to store entire string, store reminders as earlier and for each mod, store from where you visited this mod and appending what, then you can reconstruct the string when you get X mod N = 0 - <https://www.quora.com/How-can-the-problem-Ones-and-zeros-on-SPOJ-be-solved-using-BFS> <https://stackoverflow.com/questions/16945626/spoj-370-ones-and-zeros-onezero> <http://hmrockstar.blogspot.in/2016/11/onezero-ones-and-zeros-solution.html> - brilliant problem
178 BILLIARD - simple Physics problem - split into components and solve for theta and u - initial velocity
179 DOTAA - interesting logic, given damage 'd' tower can cause and number of towers, find if given heroes with given health can cross all towers when only one hero gets injured with damage 'd' everytime - interesting logic - the order of choosing heroes doesn't matter - if we find count of heroes who survive to be >= m, then possible
180 PIE - same as AGGRCOW but with floating point operations, hence in binary search, low=mid and high=mid, no mid+1 or mid-1 and no low<high or low<=high, but do it for sufficient number of iterations - like an iterative method
181 BYTESE2 - sort based question
182 SEQ - beautiful problem on recurrence matrices - for modular exponentiation of matrices, read Ajay Somani's topcoder post - <https://discuss.codechef.com/questions/2335/building-up-the-recurrence-matrix-to-compute-recurrences-in-ologn-time> <http://zobayer.blogspot.in/2010/11/matrix-exponentiation.html> - specifically from FIBOSUM and RABBIT1 --> <https://www.nayuki.io/page/fast-fibonacci-algorithms> - now, why doesn't "doubling method" from FIBOSUM work here? - maybe because matrix itself doesn't give answer like in Fibonacci sequence - in Fibonacci sequence, base case is [1 1], hence essentially, matrix will give answer - here base case is base[k] - the numbers a1, a2, a3, .. ak, not all 1's - so necessarily have to multiply arr matrix with the base matrix - [f(n), f(n-1), f(n-2)] = [[c1 c2 c3] [1 0 0] [0 1 0]] [a3 a2 a1] for k = 3 - look at LHS and RHS, now can raise [[][][]] matrix to n-k for k=3 to get f(n) - <http://www.qc.edu.hk/math/Teaching_Learning/Nth%20power%20of%20a%20square%20matrix.pdf> <http://funloop.org/post/2017-04-14-computing-fibonacci-numbers.html>
183 TRICENTR - the centroid divides median in ratio 2:1, use that to find area - then complicated set of steps for second part of answer - <http://harunurrashid-coding.blogspot.in/2014/08/problem-link-httpwww_19.html> - topcoder method is even more complex <https://apps.topcoder.com/forums/;jsessionid=9A04473DB4E1409AF895F89C8DBA700F?module=Thread&threadID=630623&start=0&mc=7#1052585>
184 COMDIV - find number of common divisors of a and b - lot of ideas from this problem - 1) iter != primes.end() and (*iter) <= a - 2) (*iter) <= a and iter != primes.end() - Now, 2) was giving WA because iter = primes.end() and (*iter) was <= a - very very tough to find out that this was the error - 1) find all divisors of natural number - they occur in pairs, so i=1, i<=sqrt(n), i and n/i pair - 2) find number of divisors of natural number - find prime factorization - 2^x*3^y*5^z.. - ans = (x+1) * (y+1) *... 3) find prime factorization of given number - for all primes in range 2 to sqrt(n) (find using sieve), keep dividing by prime - for all primes <= sqrt(n) will suffice, if prime>sqrt(n), means prime*prime = n --> so until sqrt(n) suffices - other way is to store smallest prime factor for each number in an array - here it will need sieve until 1000000, hence not feasible - but if queries are too many, it will give faster prime factorization - n = n/smallest(n) where smallest(n) is smallest prime factor of n, keep doing until 1 - here in this method we won't iterate over unneccasary primes - this is not necessarily faster than above solution, but faster than other geeks for geeks solution - given all this, our problem is to find gcd(a,b) and number of divisors of gcd(a,b)
185 BINGO - string processing
186 DSUBSEQ - long arr[26][input.length()+1] = {}; where input is a string was giving compiler internal error - no idea why - adding mod where answer can go negative is very important - i.e. ((2*x - y)+MOD)%MOD instead of (2*x - y)%MOD - logic eg: BADA - for each letter encountered, two cases, 1) add this current letter to all previous subsequences, 2) don't add this current letter - hence, ans[i] = ans[i-1]*2 - when you encounter a letter for second time, you subtract everything (all cases) to the left of the previously encountered index of same letter - i.e. A in above = ans[D] - ans[B] 
187 MZVRK - my approach was based on subtracting relevant powers of 2 from (n(n+1))/2 - c++ solution was overflowing, hence used python - simpler solutions exist: My approach was the following: - think that for each number, the Whirligig is the smallest power of two that divides it - there must be a clear pattern for the Whirligigs and it is related to the power of 2s - for each integer between 1 and 128, print the Whirligig number and the sum of Whirligig numbers up to - find the pattern and the way to calculate the result efficiently - obviously, if subtracting logic works, adding will work too
188 BSHEEP - convex hull - Graham's scan - stack based solution from Coursera Algo 1 notes Sedgewick Wayne is easier to understand than wiki one - orientation function is important - remember det of [[ax ay 1][bx by 1][cx cy 1]] gives signed area of triangle - '>0' --> Counterclockwise, == 0 --> collinear - choose lowest, leftmost point as starting point for scan - sort remaining points based on polar angle wrt the above starting point - don't actually calculate the angle, but find orientation(firstpoint, p1, p2) - if 0, then, if p1 lies to left of p2, then it is lesser, - if > 0, ccw, hence p1 lesser than p2, because first, p1, p2 lie in Counterclockwise manner - use stack to consider points in order and do Graham scan - discard points unless they create ccw turns - convex hull can also be used for finding two farthest points given a set of 2D points, coz they will lie on the convex hull - also robot traversal while avoiding obstacles
189 KGSS - range max query - segment tree with update
190 TOHU - <https://math.stackexchange.com/questions/1230223/finding-sum-k-1na-k-knowing-that-a-1-2a-2-ka-k-frack1k2> - think if telescopic cancellation is possible - generate eqn. for a(i), using sum(a(i))-sum(a(i-1)) - then sum a(i) for all i and see that it cancels telescopically
191 PEBBLE - logic question, easy O(n)
192 NY10E - simple DP - determine number of numbers made up of non-decreasing digits of a given length - e.g. - 0011 is a non-decreasing number of length 4 - here length is the only thing given - so DP on size and last digit 0-9 - dp[10][MAX] where max is maximum possible input, then sum over column to find answer for particular length
193 FREQUENT - segment tree - logic very similar to GSS1
194 CRDS - summation of two APs - problem is to find out what those two APs are - Sn = (n/2)*(2a + (n-1)d)
195 GNY07F - implementation wise, this was very very tough - see cpp - from braces, finding out level of tree, as well as traversing it fully, - as well as returning it's value - but logic wise, my implementation is shit - best logic is to realize that we are forced to insert as many monkeys as the 2^number of plies in the deepest path - no matter balanced or unbalanced - if balanced, already done, if unbalanced, we add - but in both cases, number of monkeys is 2^number of plies - for(i=n=m=0; str[i]; i++) {if(str[i]=='[') n++; else if(str[i]==']') n--; if(n > m) m = n;}printf("%d %d\n", x, (1<<m));
196 MKMONEY - compound interest - do 'val = floorf(val*100)/100' to truncate/round down to two decimal places
197 GNYR09F - I'd got so far as to realize that the dp state consists of string length, adj. bit count - also had realized that there are two or four possible cases - stings ending with 0, strings ending with 1, and/or maybe even strings beginning with 1 and strings beginning with 0 - we need to append to this - also realized that answer depends on answers of same string length and answer of (string length - 1) - but could not figure out how to avoid repetition - i.e. some were repeating - mistake was that I was considering current case as a whole - but in fact, since answer to previous stage is stored in terms of ending with 0 and ending with 1, answer to current stage should also be stored in terms of ending with 0 and ending with 1 - then it is easy no repetitions - dp state consists of [length][adj. bit count][ending with 0/1] - 3D - what I was doing was thinking of getting count of final answer and seeing final answer, binning them into ending with 0 or ending with 1 - that misses the critical point that answers to subproblems must be calculated from subprolems, you cannot calculate answer to problem from subproblems and create subanswers
198 WSCIPHER - string based rotation problem - since rotation, you can use queue - if size of set is 0, then it is corner case - do not do anything, just return - k%sizeofset will throw SIGFPE otherwise
199 MMAXPER - think like a kid DP - 1D array best until now kind of DP
200 NG0FRCTN - C++ was overflowing, hence used python - to deal with overflow can do up traversal of binary tree - remember path - followed by down traversal
201 CTGAME - this was related to HISTOGRA - but 2D - HISTOGRA was O(n), this was O(m*n) - find largest rectangle possible in given grid - do HISTOGRA for every row - consider only that row and above available squares - this will give answer for the entire grid
202 LISA - MCX Matrix Chain Multiplication like ROCK - given a string like 1+2*3+4*5, find out where to insert braces to maximize/minimize the result - once you figure out that it is MCX, then it is easy - think about strings and matrix multiplication and where to insert braces to maximize/minimize result - just like in MCX - even in ROCK it was about cutting chocolate properly - in other words inserting braces - here it literally was about inserting braces
203 GNY07C - spiral matrix traversal - encoding
204 LQDCANDY - bitsets and powers of 2, binary representation of numbers
205 GNY07D - inverse of GNY07C - decoding
206 MUL - multiply two very very large numbers - can use Karatsuba or 'FFT based multiplication of polynomials' to multiply integers which is an O(nlogn) better than Karatsuba - Used <https://github.com/vpetrigo/multiplication> implementation of Karatsuba - ab = 10^n/2 a + b; cd = 10^n/2 c + d; ab*cd = 10^n ac + 10^n/2 (ad + bc) + bd; ad+bc = (a+b)(c+d) - ac - bd; hence faster than O(n^2) ~O(n^1.5) - <https://apps.topcoder.com/forums/?module=Thread&threadID=568534&start=0&mc=9#770315> - <https://apps.topcoder.com/forums/?module=Thread&threadID=618596&mc=17&view=threaded> - <https://apps.topcoder.com/forums/;jsessionid=C78FCDDB24D62628A32D9C7389142E71?module=Thread&threadID=680738&start=0&mc=7#1262495> - FFT tutes: <http://numbers.computation.free.fr/Constants/Algorithms/fft.html> - <https://www.cs.cmu.edu/afs/cs/academic/class/15451-s10/www/lectures/lect0423.txt> - <https://math.stackexchange.com/questions/764727/concrete-fft-polynomial-multiplication-example> - <https://gist.github.com/ir5/854921> - FFT based implementation - Finally, the easiest to understand: <http://codeforces.com/blog/entry/43499> <http://codeforces.com/blog/entry/48798> - represent integers as polynomials of suitable base eg. 123 = x^2 + 2x + 3 if base 10, some bases you will get floating point errors, some bases WA, base 10^5 with long double may work - see top coder - FFT method: two reprsentations of polynomials I) coefficients of power II) point value --> need n+1 points at which polynomial is evaulated to have unique representation for polynomial of degree n - the points at which evaluation are done are nth roots of unity - If A(x) is degree m, B(x) is degree n, need mn points - steps - 1) Construct point value form of A(x) and B(x) - takes O(n^2), but using FFT, can be done in O(nlogn) - T(n) = 2*T(n/2) + O(2*n), where O(2n) is for combining the results: A = Aeven + Aodd - possible because of property of roots of unity - take motivation from Karatsuba - 10^n/2a + b style - In FFT, you basically evaluate at half of the points because of nth roots of unity 2) C(x) = A(x) * B(x) - O(n) - simple convolution 3) IFFT - again use roots of unity concept and do it in O(nlogn) instead of O(n^2) - Also, can use NTT, Number Theoretic Transform to avoid using precision issues, everything will be integers, but lot of %mod operations, hence slows things down - see cpp for better visual!
207 ENCONDIN - string processing - run length encoding e.g. 11122333 = 312233
208 LINES - slopes of lines - kinda tricky edge cases
209 HC - think of the underlying math if any - here it was like: - if the two coins belongs to the same person, the new one will be gained to hhb, or else it will belongs to lxh and lxh plays first - so it is like ++ or -- gives +; -+ or +- gives -; you can see that odd number of - will always give -, even number will always give +; and number of plus doesn't matter, you always consume + with a -, reduce total number by 1 to get a -, so that 'consuming' is a critical idea to reason as to why number of +'s doesn't affect the final outcome of whether last one remaining will be + or -
210 ICODER - 16 bit processor - hence mod 65536 - two ops - add X and mul X - do this to the number in the register - how many possible values can be left in register after given set of ops assuming we start with 65536 possible values - ADD does not change the number of values - though it may change the values themselves - since it acts only like a circular shift - MUL changes - only if you multiply by even number - procedure:1) find out if number to be multiplied is even 2) if yes, take gcd of number with the number of unique numbers left (modded number 65536 initially) 3) find nearest power of 2 of the gcd 4) divide number of unique numbers left by this nearest power - multiplying by odd number does not change the number of unique numbers - see cpp file
211 BAISED - every team gives its rank preference - find a ranking order that minimizes rank differences between preference and actual ranking - O(nlogn) to sort and O(n) to calculate differences - notice that pushing a given rank which takes current spot, below, to accomodate a preferred rank for this spot doesn't help as that given rank's difference would increase the total score which we have to minimize
212 FPOLICE - look at FISHER
213 MAJSTOR - simple enough - find score, maximum possible score in rock, paper, scissor game
214 HIGHWAYS - find shortest path between two given nodes if a connecting path exists - Djikstra or MST will work
215 HOTELS - sliding window - prefix sum + two pointer - given an array of n numbers, find sequence of continuous numbers whose value is as great as possible but less than given number m - calc. prefix sum, keep moving right and left pointers as you read input
216 GNY07H - similar to M3TILE - output fits in 32 bit int, hence MAX is 1700 found using trial and error - <https://math.stackexchange.com/questions/664113/count-the-ways-to-fill-a-4-times-n-board-with-dominoes> - so see how the last column or last two columns or last three columns can be made - can also search on OEIS to get answer directly
217 CTRICK - shuffles a pack of cards - top card moved to bottom, new top card shown, it is 1 - two top cards moved to bottom, new top card shown, it is 2, etc. find shuffling order so that above holds - doubly linked list based solution - bottom up - start from n, n-1, etc. and keep adding and shuffling - rangeMinQuery - find ith zero solution - similar to ORDERS - find 2nd zero, find 3rd zero to the right of earlier 2nd zeroth index, etc. wrap around if size exceeds number of available zeros - see cpp - look at possible RMQ applicability for shuffle, rotate around kind of questions
218 HACKRNDM - given a list, find number of pairs with difference equal to k - sorting + two pointer - this code (method?) doesn't work for arrays with duplicate elements - binary search method would be - sort, with every element as key, binary search for k-minus(key)
219 SUM1SEQ - see cpp file and Topcoder link in that - brilliant question - find one sequence of length n which sums to k, starting from 0, given n and k - e.g. n,k = 5,4 --> 0 1 0 1 2
220 BANDW - comparing chars in a string
221 CERC07R - tedious string comparison
222 MTWALK - find path that has least difference between highest and lowest elevations given grid - see cpp - tried Floyd Warshall APSP approach, but ended up solving a different problem - can't use that O(n^3) method here because of the nature of this problem - didn't use all constraints specified, which is a cardinal sin - hence seeing constraints, do binary search over possible height differences - and to find lowest - do from 0 to min(arr[0][0], arr[n-1][n-1]) - set lowest, highest will be lowest + mid where mid was found through binary search and finally try to find path with this difference using DFS - even if one such path exists for any such lowest, that means a path with difference = mid can be formed - continue with binary search - IMP - the questions asked were - do I know the difference - no, hence iterate all possible differences - i.e. what binary search is doing - for doing that, do I know the lowest limit or highest limit? - no, hence iterate through all possible lowest limits - great problem
223 SAMER08E - easy one - dates and leap years
224 SUBSUMS - though it seems similar to MAIN72, that approach is not tractable here - find how many subsets of given set have their sum lying within given range a, b - binary search, bitmask, meet in the middle - <https://www.geeksforgeeks.org/meet-in-the-middle/> - lower_bound, upper_bound - code for iterating over subsets using bitmasks - see cpp - Meet in the middle is a search technique which is used when the input is small but not as small that brute force can be used. Like divide and conquer it splits the problem into two, solves them individually and then merge them. But we can’t apply meet in the middle like divide and conquer because we don’t have the same structure as the original problem.
225 CISTFILL - given 3 dimensions of rectangular cisterns and their position from bottom, and given a volume, find at what height the water fills up or whether it overflows - if maxVol possible < given volume of water to be filled, then overflow, else solution exists - binary search on height from bottom - similar to PIE except that there we did binary search for 43 iterations - here it is while(high-low > 0.000001) - also, double compare was done using >=, not definitelyGreaterThan
226 QUEST4 - given cordinates (a,b) of leaky squares (1x1), we need to cover the floor (120x120) with (120x1) boards which can be placed horizontally or vertically - use minimum number of boards - greedy won't work - turns into maximum bipartite matching - i.e. min vertex cover - for each given cordinate (a,b), make edge from a to b and solve matching - see cpp - whenever such a situation occurs - like how to find partition - think of using grid indices - x and y cordinates as identities - in this case as vertices
227 CUBEFR - A cube free number is a number who’s none of the divisor is a cube number (A cube number is a cube of a integer like 8 (2 * 2 * 2) , 27 (3 * 3 * 3) ). So cube free numbers are 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18 etc (we will consider 1 as cube free). 8, 16, 24, 27, 32 etc are not cube free number - given a number x, find how many'th cube free number it is - example - 10 is 9th cube free number - sieve problem - precompute - multiply all cube multiples
228 SUBS - given strings x and y, find x^(max how much) gives a "subsequence" of y - binary search on max - strchr - finds first occurence of character in cstring
229 HIKE - beautiful problem - very tough to solve on own - The graph is complete and has all loops, i.e. for any two locations there is exactly one arrow between them. The arrows are coloured. There are three players, and each of them has a piece. At the beginning of the game, the three pieces are in fixed locations on the graph. In turn, the players may do a move. A move consists of moving one's own piece along an arrow to a new location on the board. The following constraint is imposed on this: the piece may only be moved along arrows of the same colour as the arrow between the two opponents' pieces - a one-person variant of the game emerged. In this variant one person moves all the three pieces, not necessarily one after the other, but of course only one at a time. Goal of this game is to get all pieces onto the same location, using as few moves as possible. Find out the smallest number of moves that is necessary to get all three pieces onto the same location, for a given board layout and starting positions - 1<=n<=50 - symmetric color matrix - output min value or impossible if not possible - see cpp file - I had a wrong initial hypothesis that they all had to travel on same color edges - the color of the self reference edge they eventually end up on - this was wrong - see counterexample - incremental Djikstra - current change effects it's neighbours, hence add to queue and check neighbours in upcoming iterations - kind of logic - update distances - this follows Floyd Warshall logic too - queue processes three at a time
230 ACPC11B - given two arrays, find two elements, one in each such that the difference between them is minimum - sort and two pointer technique
231 CRYPTO2 - writing brainfuck code - copied it - can also read <https://apps.topcoder.com/forums/;jsessionid=D358E526D306980D21B76B80B9112538?module=Thread&threadID=681001&start=0&mc=4#1263609>
232 SPEED - given speed of two persons running on circular track - +ve for clockwise, -ve for anticlockwise, find out number of unique meeting points on the circle - <https://www.quora.com/How-do-I-solve-the-problem-SPOJ-SPEED> - found pattern using spoj toolkit
233 ROADS - DP or Djikstra - Given a directed graph where each edge has attributes cost and distance, find the shortest distance possible from the vertex v1 to vN while the total cost is at most K - Costs can be zero, and two nodes may be connected by multiple edges - look at cpp file - DP similar to FISHER - in Djikstra approach - modeling vertices as representing states state[vertex, total cost already incurred] - We can have the similar table D(n,c) representing the shortest distance required to travel from state[1, 0] to state[n, c]
234 GCPC11F - easy problem
235 MMASS - bracket expression evaluation - stack based solution - copied from Zobayer aka Cacophonix
236 TRIP - find all longest common subsequences given strings a and b - LCS + backtrack - solution reconstruction Tim Roughgarden - naive backtrack is slow, how to make it fast is not intuitive - have to see what backtrack is repeating - turns out it processes same string at same index many times - hence set<string> processed[MAX][MAX] - holds processed strings at that index - this literally got the solution ACed
237 INCSEQ - DP + BIT (fenwick tree) - see cpp - beautiful problem - given sequence of length n, like 1 2 2 10 8, find number of increasing subsequences of length k - dp state - dp[n][k] - index, length - for given index i, dp[i][j] for 'each index to the right' (no way to circumvent that) which is greater than i, dp[each index][j-1] - now since it is for each index to right, have to reduce O(n^3) to O(N^2logN) - becomes similar to INVCNT - convert the 'for each to right' problem to prefix sum problem
238 FRACTION - <https://www.geeksforgeeks.org/farey-sequence/> - my solution was, generate fraction numbers with gcd = 1, convert them to double, store along with fractional form, sort doubles - turns out, can compare fractions x1/y1, x2/y2, both in simplest form, with x1*y2 < x2*y1, that works by cross multiply rule - eg. compare 3/4 and 5/9 --> 3*9/4*9 and 5*4/9*4 --> denominators become same, just compare numerators - This is O(nlogn) or O(n^2logn) or O(nlogn^2) - O(n) or O(n^2) solution is below: A term x/y can be recursively evaluated using previous two terms: x[n+2] = floor((y[n]+n) / y[n+1])x[n+1]– x[n] and y[n+2] = floor((y[n]+n) / y[n+1])y[n+1]– y[n]
239 IKEYB - this problem is an important motif to remember - given k keys and length l string, assign l letters to k keys in given order (order of occurence in string) such that minimum keystrokes are needed overall, frequency of each letter in string is given, similar to huffman reduce overall frequency of keystrokes - but greedy won't work similar to Huffman coding, see cpp - hence dp - idea is: let j+k1 = l+k2 = HAHA - if dp[i-1][j] is optimal, assigning k1 letters to ith key, in order - dp[i][j+k1] = dp[i-1][j] + cost of assigning k1 letters to last key i.e. ith key - dp[i][HAHA] = above - then if dp[i-1][l] + cost of assign k2 letters to last key < dp[i][HAHA], update dp[i][HAHA] with new reduced cost - also another array to store starting letter indices - critical idea is to assign m number of elements to the last key and use previous optimal solution and dynamically update - <https://github.com/andersonvom/spoj/blob/master/0014-ikeyb/0014-ikeyb.c> - looking for a O(kl^2) dp solution - given this, still it is not easy
240 TOHU2 - very cryptic problem statement, but very easy once question is understood
241 OAE - Find out number of strings of length n of the decimal digits 0..9 that contain an even number of 0's - found for n=1,2,3,4 then used OEIS, iterative solution
242 BYTESE1 - textbook Djikstra - referred code from SHPATH
243 THREECOL - standard dp on a tree - three coloring with given rules, find maximum number of nodes which can be colored green, minimum number of nodes which can be colored green - bottom up approach - two cases at each node - color with green, don't color with green - calculate separately for two answers i.e. maximal and minimal
244 RLM - run length encoding and decoding - perform calculation and print - copied from Zobayer - to decode, take run length as p, take digit, take digit so far as ans, do {while(p--) ans = ans*10 + dig}
245 POSTERS - given the order in which posters are hung on a wall - i.e. end points, find out the number of posters with visible sections at the end - two approaches - sweep line approach using map/set and lower::bound and greatest::less queries, making non intersecting ranges where idea is to process from last to first and see if there already exists a poster in given range and update map/set accordingly for next query OR segment tree with lazy propagation with or without cordinate compression where you again come back to front query if the given range is entirely filled with 1s which indicates that current poster will not be visible and update tree to reflect current boundary entire range will be filled with 1s - see cpp file - <zobayer.blogspot.in/2011/01/spoj-posters.html> - <http://codeforces.com/blog/entry/18588> - <https://github.com/ChrisEelmaa/SPOJ/blob/master/POSTERS.cpp>
246 CENCRY - modulo calculations problem
247 NICEDAY - see cpp - given ranks of n competitors in 3 contests - no ties, calculate the number of excellent competitors - a candidate is excellent if no other candidate is better than him (better rank) in all three contests - Binary Indexed Tree (BIT) Fenwick tree for min query (no need of segment tree) OR Set based sweep approach - one of the biggest mistakes I was making was: A is an excellent contestant if no other contestant is better than HIM, that's the only condition, I was considering a lot of other complications - see cpp - <https://www.quora.com/What-are-the-advantage-of-binary-indexed-tree-BIT-or-fenwick-tree-over-segment-tree> - invertibility of '+' and not 'min' - BIT tute <https://theoryofprogramming.wordpress.com/2014/12/24/binary-indexed-tree-or-fenwick-tree/> - for BIT approach, treat ai, bi, ci asymmetrically. We use ci as values and bi as keys in the BIT minval, queries. Idea is to sort ai's, then for ai highest rank candidate (rank 1) to lowest, i.e. sorted order - sorting helps to know all of the higher rank candidates do the following: query for the smallest value of cj (possibly infinity - initialize BIT to this), for bj in the range [1,bi] and aj < ai (notice how keys and values of BIT allow this), We have cj < ci iff contestant i is not an excellent candidate, else he is, and finally update bi index with ci - basically, for all aj and bj above i in contest 1 and 2, see if any one of them is above i in contest 3 also - if he is, then i is not excellent, else he is - for set approach <https://apps.topcoder.com/forums/?module=Thread&threadID=575041&start=0> imagine the contestants as points in 3D space. Now fix one of the axis i.e. of the contests, go from 0 to highest - i.e. from 1st rank to last rank on that axis (i.e. do a sweep), when you encounter a candidate, you would have encountered everyone else better than him at that axis (contest) - these are the possible candidates who can make this currently being considered candidate to be non-excellent, consider the other two axes of the current candidate and see whether he lies within the set or outside - if he lies within the set, it means that his rank in other two contests is worse (higher) than atleast one of the already considered candidates (and also in the first contest, because he is processed now instead of before) so ignore, else if he lies outside the set, he may change the boundary, so update the boundary by going through the relevant set elements and then inserting/removing them keep the coastline (boundary) as vertices stored in a set, to process a new point, find corresponding part of coastline (could be many points - NlogN), check whether it is eliminated, and if not, erase the points it covers and add it to the set - can be done using only one set - set of <x,y> tuples will sort by x first and then y go from lowest x to highest x or lowest y to highest y - i.e. in increasing direction (this is important) - so, given a new tuple, do a lower bound - it will give first non greater tuple, from that tuple move higher, check using other cordinate (i.e. if primary cordinate is x, check using y now) - i.e. so in this case, while x cordinate increases, i.e. sweeping right, check if points already in set have y cordinate greater than or lesser than y of current candidate - if greater than, remove, if less than, keep - can stop once last candidate is removed, no need to continue search further - i.e. break after first cordinate you don't remove. if no one removed, no need to add current tuple
248 ANARC05H - 2D grid dp - idea derived from backtracking approach to memoisation process like Mimino mentions - given string like '1117', find number of ways of subgrouping such that sum of digits in each subgroup is <= sum of digits in immediate right subgroup, except for the last subgroup, eg. for 1117, one such is 111-7, other is whole at once 1117 - index i indicates start of sub-group, index j indicates end of sub-group i.e. say arr[1][3] is subgroup 117 arr[2][3] is subgroup 17 - 0 is for number of possibilities, 1 is for sum of subgroup - process from bottom to top, process from right to left - for each entry, check all possible sub-groups to right starting from j+1 th index and if the sum is greater than current subgroup sum, add number of possiblities - hence process this too from right to left, can break earlier - answer is sum of first row possibilities
249 PICAD - similar to BYTESE2 - sort based question, people keep coming and going, what is the maximum and minimum number of people in hall within given start and end time - very weird edge cases - sort/use min Heap - combine arrivals and departures - keep count, take min/max at appropriate times - led to lot of errors as it was not clear what to do, apparently for min, except for the case of end time stamp, min can be the count after people have left the hall - I had no way to know that - <http://discuss.spoj.com/t/picad-problem-58-wa/2595/5> - is multiply by two a valid logic here? it is used in event based questions to break ties
250 M00PAIR - simple dp - was a big int problem - solve using strings in c++, I did it in python
251 INCARDS - double Djikstra - maybe BFS also possible - there is central station, given costs to edges between nodes, find smallest cost round trip for all nodes from central node 1 - i.e. have to visit all nodes from central node and visit back central node - incoming outgoing costs different - central node hints at single source shortest path aka Djikstra - do Djikstra once on outgoing edges, and another time on incoming edges - Djikstra idea of cheapest so far and boundary already explored
252 CZ_PROB1 - find primes using sieve - find which primes can be represented using sum of square integers by brute forcing till sqrt(p) - e.g. 5 = (2*2) + (1*1) and finally dp[num][1,2,3] where answer is number of unordered ways to sum to given num with 1,2,3 as the largest number - include same number, previous biggest also - very important
253 SUBSEQ - given array of integers, count number of subarrays which sum up to number 47 - one can deduce that it is either two pointer method or something to do with cumulsum (subarray = continuous = cumulsum maybe involved) - now since it is not increasing order array, we cannot do two pointer method, have to use cumulsum - notice that for each element i in cumulsum array, if we are able to find value (i-47) in the previous indices, it means we have a subarray with sum = 47, so we need to answer how many such (i-47) valued indices are present in input encountered so far - can answer using segment tree - can do even better, use map - store key as each entry of cumulsum as we come across, one by one, then value is 'set' of indices at which the key is present - do ans += size(map(key)) {map(key) gives a set whose size we need} if that key is found in the set - size - because all the indices encountered so far will be less than current index - only then add current <cumulsum,index> to the map or append index if already exists
254 YODANESS - INVCNT
255 ANARC08G - beautiful, needs situational awareness - set of n nodes, each node owes/is owed different amounts to other nodes, a directed graph, a lot of unecessary physical cash flows in the system which can be reduced, find out what is minimum cash that is required - finding cycles etc. is complicated, needs Johnson's algo <https://www.youtube.com/watch?v=johyrWospv0> - alternate approach: so let's decompose the situation step by step - consider the following graph situation: D owes 30 to A, B owes 100 to A and D owes 5 to B - so whatever happens, at D, outgoing: 35 at A, incoming: 130 at B, outgoing: 95 in other words, at each node, what is owed or what is due, doesn't change --> (1) - notice that in the above situation, 5 units of flow go from D to B to A, which is two hops instead it can go from D to in one hop, which is shorter, in that case, we will have: D--35--> A <--95--B a reduction by 5 units overall (remember DCOPs and finding shortest power supply route for given unit of flow from source to destination) - basically a MIN COST flow problem with direct link between each pair of nodes - so for each unit of flow going anywhere in the network, it needs to go by shortest path and shortest path is direct link between any two nodes which ALWAYS EXISTS because anyone can pay anyone --> (2) - from (1), we will have nodes which are in debit and nodes which are in credit and from (2), nodes in debit will directly be linked to nodes in credit so overall, least amount of paper money used is EITHER of: sum of debits OR sum of credits
256 TDKPRIME - sieve of eratosthenes - bitwise sieve - avoid even numbers, use bits of integer to mark prime or not instead of bool array - hence bitwise sieve - <http://code.cloudkaksha.org/algorithm/bit-magic/bitwise-sieve-of-eratosthenes> - also tricks in regular sieve - start inner loop from i*i and increment by 2*i --> because everything up until i-1 is covered by previous numbers and 2*i, because we only need 3i, 5i, etc. and not 2i, 3i, etc. i+i = 21, i+2i = 3i - <http://zobayer.blogspot.in/2009/09/segmented-sieve.html> - 1 2 3 4 5 6 7 8 9 will be 0 x 1 x 2 x 3.. i.e. [n/2] in bitwise rep - storing only odd numbers
257 LITE - Lazy propagation - bit flipping - segment tree - <http://codeforces.com/blog/entry/10306> Fenwick tree/BIT lazy propagation also exists
258 MIDO - edge case handling and reading problem statement carefully
259 LPERMUT
260 CYLINDER - geometry - divide into cases and solve - given a technique to form cylinder - cut sheet of paper - horizontally (parallel to shorter side) - one part use to form roll, other part make bottom circle - top side is open - what is maximum volume cylinder possible? - nowhere is it given that two parts have to be equal after cutting - a mistake I was making - two ways to roll cylinder - one along width, one along length - if you roll along length, max radius of base cannot exceed w/2 where w is shorter side - take maximum of two vols possible
261 COEF - find coefficient of a^n1, b^n2, .. in the expansion of (a+b+..)^n where n1+n2+..nk = n - nck problem - multinomials - sort, highest power to lowest power nk's - then nc(highest power), n = n-highest power, newnc(second highest power) .. etc. - ans is product of all these
262 AMR10C - good problem - look at COMDIV - any factor/divisor problem, try to relate it to prime factorization and see if it helps - prime factorization by keeping on dividing by smallest to greatest prime is faster than (smallest prime factor) geeksforgeeks <https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/> method which I've used in the code - once you have prime factor, you can group all different primes in one bundle, keep doing, hence ans. is max(m,n,o..) in (a^m b^n c^o = prime factorization) that number generated from each bundle will not be a perfect sqauare because you're generating it from 'smallest prime numbers' and say max(m,n,..) = m and m-something = m1 2's are left over say, you cannot group them amongst themselves as they create a square - by bundling, you're ensuring 'minimum' and by using prime factors you're ensuring 'square' property - Eg. for question: 1) 24 = 24 but 4 divides 24 and 4 is perfect square . So , Rejected. 2) 24= 12 X 2 but 4 again divides 12 so , this is also rejected. 3) 24 = 6 X 4 ; This is also rejected as 4 divides 4. 4) 24 = 6 X 2 X 2 ; Now this is acceptable. And this is what we will find that is minimum such possible divisors used satisfying above conditions so mentioned. Hence ans for 24 is 3.
263 ACPC10E - easy
264 PARTIT - 3D DP with reconstruction - also try to precompute DP table in whichever question possible - partition of integer m into n components is a sequence a1a2..an of positive ints with ai>=aj for all i>j i.e. non decreasing such that their sum = m - determine kth lexicographic partition that sums to m in all n component partitions - you can see that we need len,sum,lastdig as dp state - cannot reduce it further - learnt to modify state to answer what the question at hand asks instead of overcomplicating things with vector of vector<int> in DPArr - so if you cannot reconstruct, try modifying state - here it was [lensofar][last number][sumsofar] - instead change to [lenleft][last number][sum left] - this enabled reconstruction
265 PHIDIAS - also look at PIGBANK - rectangular plates of sizes W1xH1, W2xH2, ..WNxHN are needed - given a huge plate of size WxH, this should be cut to obtain slabs of desired sizes, any piece can be cut horizontally or vertically, cutting COMPLETELY through that piece - pieces cannot be rotated, so WxH != HxW, a marble plate is wasted if it is not of ANY of desired sizes after all cuts - so you can have multiple pieces of same dimension and none of the other case, no issues - how to cut initial slab so that as little of it as possible is wasted - see CPP, 2D dp - for each WxH - answer depends on everything smaller than current pair - so for i,j, dp has to be calculated for everything upto i,j-1 and i-1,j - now I didn't know what to store in dp[i][j] - after some trials it is obvious - that storing sum of rows as dp[i][j][0] and sum of cols as dp[i][j][1] will not help - seems like have to store either either max(total filled area) or min(total wasted area) at each i,j - since we're looking at min wasted area, makes sense to store that - MAIN IDEA was can cut slab either horizontally OR vertically - and cutting COMPLETELY through that piece - so read such statements in question carefully - then considering each of the N input slabs and performing dp[i][j] = min(dp[i][j], min(vertical cut, horizontal cut)) will NOT work - as that slab can be placed anywhere within the i,j slab and then min taken -  if you do that then it will work - what we need to do at each i,j is to consider cutting at ALL possible intermediate i's and ALL possible intermediate j's and take min of all of those so O(W*H*max(W,H)) complexity, cannot do in O(W*H*N)
266 PRISMSA - simple calculus - maxima, minima problem - double precision
267 QUEST5 - create ordering similar to PICAD - found out how to delete just one item if multiple are present in multiset - find that element's iterator and do an erase(iter) - time complexities of these kind of schedule questions are generally O(nlogn) which is the complexity of sorting
268 GOSSIPER - each of N people has gossip, when two gossipers meet, they exchange all gossip they know, M meetings happen, find out whether everyone knows all gossips or not - have to find UNION and see if size = N at the end for all gossipers - set Union passed but was slow, bitwise OR using bitset was so much faster - bitset is good for set operations - the idea of transitive closure doesn't work here because transitive closure answers questions about whether there exists a link between 'A' and 'B' - not about WHEN it was created - so if A<-->B (directionless graph) then B<-->C and finally C<-->D, transitive closure will say yes for A and D (because there exists a path between them in both directions), but D's gossip is not with A because of the 'timing'
269 PLONK - given n points (x and y coordinates, where distance between them is Manhattan distance and can be computed in O(1) time), find which point is best for meeting - i.e. sum of distances from all other points is the minimum - kinda like finding midpoint in 2D - hence I thought mean is appropriate - idea was right, but I used the wrong statistical measure - mean isn't the answer - median is the answer - <https://apps.topcoder.com/forums/?module=Thread&threadID=513921&mc=15&view=tree> - sort x and y separately, using indices, we can quickly compute change in sum of distances if we calculate for the first index, everything to right of i decrease by difference between i and i-1 and everything to left of i-1 increase by difference between i and i-1 - update distarr at relevant indices - as x and y are indpendent, because of Manhattan distance property, we can process them independently - also remember kth order statistic - find kth element in sorted list given unsorted array - O(n) average algo is possible - QSELECT - we know pivot is in correct position, recurse in required partition continue till pivot is kth element
270 NOCHANGE - beautiful, IMPORTANT - look at the approach - see the simple DP state, answering in terms of whether or not it is possible and using only coins from left to right once - yes or no answer to whether we can pay whilst satisfying the conditions - The input starts with the amount of addollars to be paid x, where 1≤x≤100,000. The number of different coin values k follows, where 1≤k≤5. The values of the coins v1,…,vk follow, where 1≤vi≤10,000. Notice that the order among coin values is significant: you need to spend at least as many coins of value v1 as coins of value v2, at least as many coins of value v2 as those of value v3, and so on. You may assume that you have a sufficiently large number of coins of each value - see cpp - O(x*k) - we increase i from 1 to n and for each i, we try to find if we can use coins to form that i, so coins - only one way - use c1 or c1 c2 or c1 c2 c3,,... if you use current, have to use one of each previous - now we have to check two things - if sum[c1, .. whatever we've used] <= i and also dp[i - sum[..]] = true and only then dp[i] = true - this means we've achieved the smaller sum while satisfying the coin condition - eg. i = 14, let's say we use 4 c1 and 3 c2, to get 10 - we need to check if i=10 was possible earlier - if it was, say 2 c1, 1 c2, then 4+2 and 3+1 still satisfies condition - that is the KEY LOGIC - if for smaller sum condition satisfied, then for larger sum, the condition will be satisfied IF the condition is satisfied for the differnce - here 10 was the difference in that example - you only need to check O(k) for each i - cumulsum of coins
271 CRYPTO1 - given n and p, find x where x^2 congruent to n mod p - modular exponentiation, quadratic residues, Fermat's Little Theorem, Euler's criterion - <https://www.geeksforgeeks.org/eulers-criterion-check-if-square-root-under-modulo-p-exists/> - <https://www.geeksforgeeks.org/find-square-root-under-modulo-p-set-1-when-p-is-in-form-of-4i-3/> -<https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus>
272 ANARC09C - prime factorize two numbers a and b, find cardinality of union of set of prime factors of a and b (no need of bitset for this, add prime factor directly to a set and take size(set) at end) and find difference between powers of prime factors (diff. = value of one of them, if one of them is 0 and other has value, else abs(diff in values))
273 YAPP - How many permutations of the first N numbers exist such that the maximum element between the indices [i..j] is either present at index i, or at index j ? - all permutations in which the largest digit is at extreme are valid - the condition given is not satisfied only when there is a bigger digit caught in between two smaller digits like 132.. - hence start from highest digit - two possible places - rightmost, leftmost, then next highest digit, for each of the earlier possiblities - two possible places, left end, right end.. - so ans. = 2^(n-1) where n is the number of digits - n-1 because only 1 place will be left for 1 at the end - solve by modular exponentiation
274 ARRAYSUB - given array n and window of size k, k<=n, for each sliding window (continguos subarray), output the maximum element in that window - first solution was to use heaps, storing the indices, works fine, but O(nlogn) - second solution using deque is O(n) - remove redundant elements - every element is inserted or removed once and all the add and remove element happen from front or back (unlike heap, where insert takes log(n) time) - at each point in time, front of queue will contain maximum element of that sliding window - when you come across a new element, pop all elements in deque from back which are less than new element because they are now irrelevant - also pop all elements from front which are out of index (left border) - out of the box thinking as one would think that we need to hold 'window size' number of elements at a time - as always it helps to keep only what is required and eliminate needless data - i.e. whatever is bigger and within index - like the Goldman Sachs interview question where you only needed to store min ele seen so far, all others ele to left of that min ele are redundant
275 DIV - d(N) denotes number of positive divisors of N where 1<=N<=10^6 - for each d(N), print if d(N) = p*q is possible where p,q are distinct primes - copied optimized prime factorization from AMR10C - idea is to find number of positive divisors for each number using sieve technique - then for each of those numbers, have to find if it is expressible as p*q where p and q are distinct primes - this happens only if prime factorization contains exactly two distinct primes
276 ZSUM - For two given integers n and k find (Zn + Zn-1 - 2Zn-2) mod 10000007, where Zn = Sn + Pn and Sn = 1k + 2k + 3k + … + nk and Pn = 11 + 22 + 33 + … + nn - 1 < n < 200000000 and 0 < k < 1000000  - looks indimidating at first, but it is just solve equation (because of -2Zn-2, all terms except 6 in total cancel) and then solve for that using modular exponentiation - huge powers with mod, think modular exponentiation
277 MBLAST - why this 2D grid DP works is very important - similar to EDIST which in turn is similar to LCS - in all these problems, action seems to be happening at the rightmost end - one possible way to reason about this is that if you claim that x-4,y-4 to x,y is optimal, it has to be through sequence of operations, you can 'order' the operations incrementally, say x-4,y-4 to x-4,y-3, etc. one allowed operation at a time and finally get to x,y - which means if you have optimal answer to x-1,y and x,y-1 and x-1,y-1, you can get the final optimal answer using one allowed operation - if you say, you will add/delete/edit to left of x-4,y-4, then you can consider steps after starting from that left element and come up to whatever you'll end up with after add/delete/edit to left of x-4,y-4 - because the operations are communicative - look at sequence alignment from Tim Roughgarden <https://www.youtube.com/watch?v=uYH6fSQJmuw> - if an optimal solution is given to you, how will it look like? he says X,Y if optimal are xm and yn with different number of gaps, but X,Y of equal length - now consider rightmost part - 2 possibilities for X and 2 for Y - either letter or gap so 4 possibilities when matched, but gap with gap is never done so i) if two letters matched and are optimal, then X-xm and Y-yn are optimal ii) if xm matched  with gap, then X-xm and Y are optimal iii) if ym matched with gap.. proof for i) if X-xm and Y-yn are not optimal, then use that optimal solution to match X-xm and Y-yn and then match xm and yn to get better than X,Y which is a contradiction - so finally, find optimal from amongst these three cases
278 HALLOW - see cpp - Given n numbers, where n>=c numbers, each >= 1, how can you choose a non-empty subset of the numbers so that the sum of the subset is a multiple of c? - my first thought without reading the constraints was to think that sum for all possible subsets would be necessary - did dp for that which is infeasible as 1<=c<=n<=100000 and dp[1<<n] will lead to a segfault - if n>=c, then pigenhole argument helps, if n<c, then <https://www.geeksforgeeks.org/subset-sum-divisible-m/>, an extension of subset sum from MAIN72's geeksforgeeks link - but this question always has n>=c - look at pigeonhole argument - <https://www.quora.com/Given-N-numbers-how-can-you-choose-a-non-empty-subset-of-the-numbers-so-that-the-sum-of-the-subset-is-a-multiple-of-N> - code solution seeing this - use map to store mods found so far
279 CANDY2 - given a set of n bags with ai,bi,ci of choc, stra, bana candies in it, choose three bags one for each of choc, stra, bana so that they hold only candies of that flavor, all others have to be transferred to these three bags using minimal number of moves - on working out a few examples, it became clear that a greedy solution would not work - so solution is as follows: for each flavor (C,S,B), pick the three different priority bags - you can do that through sort or through finding three greatest elements in list in O(n) time using if else if - now a solution is guaranteed to exist in this 3x3x3 solution space through which you can brute force even if there is tie i.e. eg if C and S both prefer say bag 5 for first spot, still since you have three different bags for each flavor, you can break tie optimally by bruteforcing through this size 27 solution space
280 PROSCORE - simple problem
281 DQUERY - beautiful approach - offline processing - given n numbers and q queries of form [a,b] where 1<=a<=b<=n, find number of unique numbers in the range of each query - see cpp for explanation of offline method using BIT(Fenwick) tree - result of a query [a, b] is number of integers whose last occurrence in [1, b] is >= a - converts range query [a,b] to a form where prefix sum [1,b] can be used albeit maintaining the correct information in the tree and updating at appropriate times - take queries (key is b if [a,b] is range) and numbers (key is index) together and sort and process in that order - on seeing a number event, if number already occured, update BIT accordingly, - if query event, query BIT for given range - can use MO's algorithm which is square root decomposition, but that is done in another problem - can also use Persistent Segment trees with Online querying <https://www.quora.com/Is-there-any-way-to-solve-the-dquery-problem-on-SPOJ-using-persistent-segment-trees-an-online-solution>, again done in another problem - both topics are on Anudeep's blog
282 TAXI - maximum bipartite matching - BPM - solved after reduction to maxflow - can also solve using Hopcroft Karp algorithm, which is a faster than 'max flow' method to find maximum matchings in bipartite graphs - <https://www.geeksforgeeks.org/hopcroft-karp-algorithm-for-maximum-matching-set-1-introduction/> - Konig's theorem <https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory)> - (min) minimum vertex cover in bipartite graph = maximum bipartite matching = can be reduced to max flow - <https://www.geeksforgeeks.org/maximum-bipartite-matching/> - all trees are bipartite graphs - see PT07X
283 DFLOOR - beautiful application of Linear Algebra and observations/deductions - floor with lights on tiles - on/off - random initial state, finally everything to be switched on - if dancer steps on tile, he toggles state of current tile and 4 immediate neighbours - find if possible to turn on lights on all tiles everything by stepping on whatever tiles required - beautiful application of Linear Algebra and observations/deductions - OBV1: Visiting a cell odd number of times will invert state, even number, same state So useless to visit more than once - so either visit or not - OBV2: State of cell is dependent only on at max 4 neighbours - so write eqn. in terms of neighbours i.e. ans[i][j] + ans[i+1][j] +.. if the sum turns out to be odd, then final state of i,j will be inverted, else same as orig state, To conclude, we need it to be odd if 0 inititally, even otherwise - OBV3: Carrying on from above, value of every cell on particular row will depend on values of cells on previous row - so apply equation for top row and if 0 initially, we need sum to be odd and sum even if 1 initially - So if somehow we fix the values of top row, we will know what value to use for cell immediately below - to make the top row cell 1 or 0 and this is an induction and continues downwards - So for top row, try all possible combinations - Then for all the next rows, if top row respective col is 0, flip, else let it remain same - finally bottom row, check if you have all ones, then possible, else not - This was computational approach given on <https://www.quora.com/How-can-I-solve-DFLOOR-problem-on-SPOJ> - Mathematical approach is to write it as Mx = y and solve for x <http://aix1.uottawa.ca/~jkhoury/game.html> <http://aix1.uottawa.ca/~jkhoury/gamesolution.htm> by solving a set of linear equations - also can find path with minimum possible steps with this
284 AMR11E - simple problem related to fast prime factorization
285 MBINGO - brute force
286 RPLC - easy prefix sum
287 MAIN72 - subset sum - find sum of all those integers which can be expressed as the sum of atleast one subset of the given array - brilliant, but you have to sort first and elements have to be unique <https://stackoverflow.com/questions/18305843/find-all-subsets-that-sum-to-a-particular-value> - more general <https://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/> - outer loop sums over all indices of array, inner loop sums over all sums - O(n*S) where S is max possible sum i.e. sum of all elements
288 ADV04J - given point and regular polygon, how many line queries (on which side of the line is the point) are needed in the worst case to check if point is within the polygon or not - notice that if you draw line on diagonal, you split polygon into two, next again you can split the already split part into two, .. - so powers of two - log2
289 PUCMM025 - divisibility - divisibility test for 7 copied from - <https://github.com/velazqua/competitive-programming/blob/master/online-judges/SPOJ/PUCMM025/PUCMM025.cpp> <https://kartikkukreja.wordpress.com/2013/12/22/divisibility-rules/>
290 SOLDIER - kinda like knapsack dp, but you're forced to pick one from each category of items - 6 categories of items - for each, price and quality given, max amount which can be spent is given, to maximize the total quality of equipment where total quality is the quality of item with the lowest quality out of the 6 - notice that somehow an umbrella man kinda for each rupee spent what is the best possible buy kinda approach is possible - bottom up dp - but then you have 6 items, one of each kind, how to go about all possible combinations of these - the trick is to realize that ordering doesn't matter - so do for 1 item in first iteration, do for 2 items in second, do for 3 items in third,.. - for 3 items in third, you already know best possible for given price for 2 items, so consider each third item at given price point and subtract its price - find best from 2 items given this subtracted price - so bottom-up - to make it more efficient, no need to do for each item at every price point - sort by price and do a[i] = a[i-1] i.e. copy previous best to current, then see if current improves - take care because higher price may not mean higher quality - to handle this keep track of best quality seen so far at previous iterations (at lower price in other words) - and apply that item too to see if it improves total quality - maybe somewhat similar to what I was thinking for NOCHANGE initially (but NOCHANGE turned out to be different) or some other earlier problem
291 SAMER08C - interesting dp - grid with number of candies in each cell - if you pick one, upper row, bottom row, cell to left and cell to right are emptied - find maximum number of candies to pick - OBV1: within a row, say if we have 5 columns, can pick 1,3,5 or 2,4 kinda method, hence dp technique - use i = max(i-1,i+(i-2)) - OBV2: now you know how much max you can get from each row - if you pick a candy on a row, upper row and bottom row vanish - so you have to select certain set of rows to maximize candies - use i = max(i-1,i+(i-2)) dp technique to find which rows to select
292 MYQ1 - simple if-else
293 ANARC05I - 2D diag - 0,0 start - U,L,D,R - drawing line segment all the time - segments can intersect but cannot overlap (i.e. two segments can have at max. 1 point in common) - what is number of closed polygons? - once you get the idea, rest is just implementation - maintain boolean array to keep track of line segments - two cases i) one intersect, new polygon is formed ii) second time intersect in same direction, that means line divides existing polygon into two which is nothing but equivalent to new polygon gets formed - hence keep track of direction and number of polygons formed
294 MUDDY - interesting - remember that Konig's theorem states the reduction of min vertex cover on bipartite graph to max flow problem - if you have something that looks like min vertex cover/min set cover, try to look out for this - i.e. problem statements like minimum number of edges/boards/whatever given a graph/2D grid - then look at how given graph can be converted to Bipartite graph whose minimum vertex cover helps solve the problem instead of directly trying to apply maxflow - given a grid with * and ., where * indicates muddy spot and . clean - have to cover *'s with rods, vertical or horizontal, use minimum number of rods - this problem didn't look like it can be done by dp, greedy might be possible - but didn't look to disprove that greedy was not possible saw maxflow tag, came so far as to deduce maximal length vertical and horizontal bars, but didn't know how to use that - then see min set cover problem, min number of subsets to form a set but that's np complete, hence look at min vertex cover. But not on a generic graph, but on a bipartite graph, since only then reduction to max flow is possible - if you see maximal vertical and horizontal length rods and play around, you'll get the idea, given that we're trying to minimize the number of rods we need to use - for each muddy spot, we'll either select a horizontal rod or a vertical rod - since it's either, those are the two partitions of the graph - connect source to all vertical rods and sink to all horizontal rods and find max flow - this will find min vertex cover - which in turn means minimum number of vertices (horizontal or vertical rods) which cover all the edges (edges are muddy spots here)
295 TWINSNOW - sorting & total ordering - given a large number of sixtuples, find if two pairs of sixtuples are alike - The sixtuples will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms - beautiful problem on the concept of defining a total ordering - map was too slow, hence I saw online that the method used was sorting - so if you think carefully, you'll see that for two similar snowflakes to exist, two conditions need to be satisfied i) the two must contain same 6 integers ii) they must be contained in the same order (forward or reverse) first is easy to check by sorting, now how to do second by sorting? see carefully to see that if you define a total ordering between any two snowflakes, you will have them next to each other on sorting if they're alike - the key being how to define a total ordering - how to do it? - consider all possible combinations, choose the smallest - 12 combinations, 6 start points, 2 - one forward, one backward for each of the 6
296 TRIKA - easy dp
297 GERGOVIA - greedy - one array with + (buy) and - (sell) numbers, such that total buy = total sell (don't know how this changes things), with transport cost of 1 per bottle per unit distance, assume each element of array is separated by 1 unit distance - find cheapest total cost - given that it is greedy, then it becomes slightly easier to solve - notice that it is costlier to keep earlier demands pending for longer time because the distance increases, hence earlier a demand occurs, earlier it has to be satisfied - something like fcfs which motivates something like a queue - but how about handling things to the right which we haven't seen yet - treat buys and sells similarly - meaning buy = -sell like they can be treated homogeneously i.e. maintain two queues and use appropriate signs + and -, then that problem gets solved, so in short, keep a buy queue, keep a sell queue, satisfy buys and sells as you traverse from left to right
298 BTCODE_D - easy
299 ALICESIE - clever - Sieve of alice - sieve of alice upto n = all the numbers which do not have a product <= n - notice that the answer to how many divisors left will change only if a new divisor will be found - so for any i, a new divisor will be first found at 2*i, so only at those places (multiples of two) ans[i] = ans[i-1] - 1; Else it is always ans[i] = ans[i-1] and of course, add the current number as it is a trivial divisor and shouldn't be counted
300 DEFKIN - towers in a grid given, no two share the same row or column - they are like rooks, defend along straight lines, find max possible rectangle that is undefended amongst all the undefended rectangles that get created - the thing to notice here is that each consecutive two towers along length will influence all other consecutive two towers along breadth and vice versa so find max consecutive two along length (after sorting) same along breadth, product is the answer
301 CPRIME - use this code for Sieve of Eratosthenes - given n, find number of primes <= n - sieve and upper_bound
302 PANCAKES - easy

Eggs and floors - <http://rushikdm.blogspot.in/2016/12/e-eggs-f-floors-puzzle.html>
GOLDMAN SACHS <https://www.geeksforgeeks.org/maximum-difference-between-two-elements/> a[j] - a[i] such that j>i
ARRAY Q1 <https://www.geeksforgeeks.org/find-number-subarrays-even-sum/> find cumulative sum and use odd + even = odd - so between two odd cumulative sums lies an even sum subarray, even + even = even - so between two even cumulative sums lies and even sum subarray - so count number of odd cumulative sum indices, do nc2 - take two at a time thing and similar for even cumulative sum indices
ARRAY Q2 <https://stackoverflow.com/questions/45645728/given-an-array-find-the-number-of-sub-arrays-with-m-odd-numbers> one approach is for every interval in [i,n], find first posn that results in m odd numbers, and first posn that results in m+1 odd numbers, then subtract them - that means i to m is given array, every index after i till m+1th odd can be included or removed giving first(m+1) - first(m) ways of doing this - binary search to find those indices - need sum array for each i, holds number of odd numbers in [0,i] - O(nlogn) - second approach is O(n) - generate an array of lengths of gaps between odd numbers, counting both ends as implicit odd numbers, eg. for 1 2 3 4 5 it is 0 1 1 0 - 1-3 is 1 and 3-5 is 1, the 0's are for implicit odd - then for each i, sum over (g[i]+1)*(g[i+m]+1) which is basically how many subarrays start at or just before ith odd and end at or just after i+1th odd - multiply both values to get number of ways
PAVAN - given an array with n elements, calculate number of subarrays with equal number of odd and even numbers - or even find the size of the largest such subarray <https://stackoverflow.com/questions/41269448/algorithm-array-with-odd-and-even-numbers> odd numbers - -1, even numbers 1, find cumul sum, subarrays with equal odd and even numbers are the ones where the cumulsum at start of subarray = cumulsum at end of subarray - so for each possible cumulsum store number of times it occurs, do sum nc2 to get answer - to find largest such - you can store sizes (indices) and do the above or - store largest right index for each possible given cumulsum, later traverse from left and for each cumulsum, find respective entry from map/array and subtract indices to get size - find maximum such difference to get largest size
PAVAN counting type problems - given an array of n numbers, find the summation of bitwise OR of all possible subsets of this array - bitmask is slow - instead use counting approach which exploits these bitwise properties of OR or XOR or AND - <https://www.geeksforgeeks.org/sum-xor-possible-subsets/> <https://www.geeksforgeeks.org/calculate-sum-of-bitwise-and-of-all-pairs/> - in this problem, once a bit is set, it will contribute to sum in all subsets that include the number in which it is set - so subtract 'value' * 'number of subsets where that bit is not set' - eg. A = {2 3 5 4} - third bit is not set in 2 and 3 - so 2^2 - 1 subsets - exclude null - value: 2^2 = 4 - subtract 4*3 from max possible sum - do this for all bits - for XOR, a bit contributes in half of the possible subsets - enumerate and see this to realize - kC2 - possible ways of choosing two at a time - because 'pairs' - linear time approaches
PAVAN pattern matching in strings - given a string say FLIPKART and a pattern with letters and/or * (matches only with more than 2 letters) and + (0,1 or 2 letters), find if pattern matches with string - 2D grid dp like EDIST, LCS
PAVAN OS scheduling - given N processes with Arrival time and processing time, calculate minimum number of cpu's required if maximum allowed turnaround time for each process is 10 units. turnaround = waiting time in queue+processing time. Each cpu has its own processing queue. Processes cannot be preempted. Max allowed cpu's = 5, print -1 if more than 5 required. Eg. T1 2 arrival, 7 processing, T2 3 arrival, 5 processing - Output: 2 cpus required, with 1, not possible - for each currently existing cpu, maintain start time and processing time of currently executing process and processes in the queue of this cpu - also can maintain when cpu will be available next - when new process arrives, if wait time > 10 - processing time for this process, then new cpu required, add cpu to vector of cpu's and maintain queue for that - cycle through existing cpus whenever new process enters - need not delete a cpu once it is created since we only need minimum number of cpus required - <https://cs.stackexchange.com/questions/91864/how-to-approach-solving-this-variation-of-the-job-scheduling-problem>
PRINCIPLE OF INCLUSION EXCLUSION: kick3.cpp