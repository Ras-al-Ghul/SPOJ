ajay somani's notes on TC
Modular exponentiation and modular multiplication
Concept is quite interesting
modexp - multiply the base by itself, then multiply earlier product with itself, etc. if odd, multiply by base.
modmul - multiply by two, then multiply earlier product with itself
if odd, add in final step.
problems may involve matrix exponentiation - do it on matrix ops now

Some facts on euler's totient function from TC tutorials again
For prime p, for phi(a*p) or phi(a^p), etc.

1 TEST - Test
2 PRIME1 - Primality square root bound - one of the factors to be <= (sqrt N) - two sieves - one up until sqrt(largest number), use this to eliminate numbers within given range which is second sieve - segmented sieve - PRINT is similar which I've done
3 ONP - Reverse Polish Notation - look at complete input file - don't assume things
4 FCTRL - Print trailing zeroes of factorial of number - have to count even numbers and number of multiples of 'powers of 5' - powers of 5 because, eg: 25 - 5*5, one extra 5 - product of these give rise to zeros - since in a given range, number of even numbers is greater than number of 5's, counting the number of 5's is enough - have to look at optimizing logic like that to not get TLE
5 FCTRL2 - Big Integer problem - 100! - the number of digits in a number n is log(n) - number of digits in n! is log(n!) = log(n) + log(n-1) + ... - approximation of factorials are calculated using Stirling's approximation which is not needed here
6 CMPLS - Lagrangian interpolation, Lagrangian polynomials - complete the sequence - method of successive differences, forward differences table this should come to mind when sequence is continuous i.e. for f(i), f(i+1), f(i+2), etc. given in order cannot use if f(i), f(i+5), f(i+x), etc. are given
7 ADDREV - <algorithm> has reverse()
8 TOANDFRO - string ordering and pattern
9 CMEXPR - remove unneeded parantheses - accessing array elements out of bounds need not give segfault - may give random values - use stacks for detecting open brace, close brace - check all input test cases and even more because they might not cover everything - the approach was to consider each brace pair at a time for each brace pair, consider a list of curoperators (bear in mind that there can be more than one) for each brace pair, find the prevoperator and nextoperator if it exists check if the conditions are satisfied for each element in the list of curoperators only then remove the braces - can finish in one pass
10 JULKA - big numbers - take care of variables which are being reused
11 NSTEPS - pattern identification
12 SAMER08F - count squares within squares - sometimes formula might work better than loops - derive formula from loops if possible - if time limit is strict it will be needed
13 FASHION - sort vs. using something like heap - which is better to use - see number of operations and complexity - number of insertions, number of elements, how they will be used, etc.
14 CANDY - nothing touch
15 CANTON - pattern identification
16 COINS - easy dp - find optimal substructure - try catch for bad alloc in dict for dp - if it is full, can't add to dict, have to calculate - also maintain global dict if same dict can be reused for different test cases
17 LASTDIG - last digit of a^b, hence a^b mod 10 which is Modular Exponentiation
18 HANGOVER - floating ops - don't approximate unecessarily - float = 1.0f - look at this problem for floating point comparators
19 PERMUT2 - forgot to use delete[], cost 1 SIGSEGV - SIGABRT caused by problems with memory allocation
20 CANDY3 - simple problems may have huge test cases
21 EIGHTS - find kth number whose cube ends with 888 - find pattern, turns out to be AP - I didn't spot that - cannot increment counter and keep count - will be too slow - hence set digits of answer in an array, directly based on known pattern
22 AE00 - how many rectangles can be formed with unit squares - try to simplify the math even though it may take time this will lead to faster solutions - underflow, subtraction, unsigned numbers
23 ABSYS - string processing
24 AP2 - see if some values can go -ve while using unsigned numbers - d in AP might be negative even if all terms in AP are positive
25 ACODE - single scan DP - number of ways in which string can be decoded - I was considering c[0] <= 2 and c[1] <= 6 what I wanted was c[01] <= 26 for what I was doing, 17 doesn't pass - instead of recursion with function calls for dp, better is single scan left to right dp - look for such methods in string questions - d[i] = d[i-1], if d[i] and d[i-1] < 26, then, d[i] += d[i-2] because d[i-1]d[i] can be read together or one by one - string.erase(index, num of characters to erase)
26 ACPC10A - find if AP or GP, give next number in sequence - if problem is easy, then it is about handling all edge cases
27 STPAR - stacks, parade vehicle ordering
28 BISHOPS - number of non-threatening bishops on 'large' chessboard - identify pattern problem
29 ARMY - Godzilla vs. Mecha - min_heap using pq - priority_queue from <queue>
30 TRICOUNT - Triangle within triangle - count them - oeis.org - enter few terms of series, get formula - which is easier than deriving formula yourself
31 STAMPS - priority_queue - look at how to implement both min_heap and max_heap
32 GUESSING - online game - the actual game is to find an optimal sequence of guesses so that you get to the correct number as soon as possible - at each guess you get some information in return which you can use to formulate next guess - GUESSLNK is tougher - yet to try
33 JAVAC - string transform - java to c++ identifier and vice versa, if none, report error
34 OFFSIDE - detect if player is offside or not - read constraints carefully and direct code 
35 FENCE1 - floating point op - double format specifier is %lf
36 NGM - Turn taking game - integer given on the table - subtract any non zero digit from this number on the table - take turns, whoever writes 0 last wins - initially it looks like DP - best solution of subgame, then best solution within that subgame etc. - but the decrease in size of function at each iteration was not sufficient - hence runs out of stack space for recursing - in the end, Game Theory class example was sufficient - look at what move I make so that his move is forced - basically try to control the game if possible
37 EASYPROB - see pattern and code - had to submit text file with answer
38 EGYPIZZA - find minimum number of pizzas to order so that everyone gets their quantity from one pizza itself - check how to club the given fractions - 1/4, 1/2, 3/4 minimally, and code
39 NEG2 - numbers in base (-2) - look for pattern and code
40 MARBLES - Purely mathematical - bars and stars technique <http://www.mathsisfun.com/combinatorics/combinations-permutations.html> <https://en.wikipedia.org/wiki/Stars_and_bars_%28combinatorics%29> <https://www.statlect.com/mathematical-tools/combinations> <https://stackoverflow.com/questions/15301885/calculate-value-of-n-choose-k> --- look up Pascal triangle - DP method <https://en.wikipedia.org/wiki/Multiset> <https://www.quora.com/How-do-I-divide-a-given-number-into-a-given-number-of-parts-randomly-and-uniformly> - remember what is a multiset, n-1 C k-1 - no zero allowed, n+k-1 C k - with zero allowed formulas - fast way to calculate nCk = (n * (n-1Ck-1))/k - also (n+1 C k) = nCk + nCk-1
41 MAYA - numerical system of the Maya - string processing
42 PIGBANK - bottom up DP - if algo feels wrong - like you feel that there are too many corner cases, then it mostly is wrong - for eg. top down needs too many edge case handling here - also, in memo table for DP, what is chosen as key, what is value, are there duplicate keys possible - in this case it is two coins of same weight, then value should be one with lower value, because problem is about finding minimum amount of money that must be there in piggybank given that it's weight is so much and weights of individual coins are given - top down feels like there are so many possibilites, hence intractable - bottom up approach is, for each weight starting from min value, add the minimum weight coin, or the new coin - new coin may be added only at multiples of it's weight - and only if it reduces the value
43 SBANK - large numbers sort - hence, use map - also keeps track of frequency
44 PIR - volume of pyramid - different formulas were giving different floating point answers - hence many WAs
45 CADYDIST - candy distribution - priority_queue
46 PT07Y - find if graph is tree - iterative DFS - check if you visit a node twice - then graph, else tree - also in neighbours, you will consider all nodes except parent node (node from which you visited the current node) - adjacency list to store graph - DFS approach is as follows - maintain a 'parent' for every node - from current node, after marking it as visited, while adding all neighbours to DFS stack, mark parent of neighbour as current node, unless the neighbour is parent of current node, in that case, mark parent as itself. Also maintain 'visit' field. If you've visited the node earlier and it's value != parent, that means, it is a cycle - because you're visiting the parent from a node other than its child, hence a cycle - note that almost any recursion can be converted to iteration notice that in recursion, the topmost element on the stack gets evaluated first. So if you're looking for an order in which to do iteration, go to the end of the list and come back to front. - can be done with BFS too - also, better than maintaining parent, etc. is to not add parent to DFS stack itself - so if you visit an already visited node, it necessarily means a cycle

68 ROADNET - Shortest path - Djikstra's algo - O(N^3) method maybe faster. Update of hops is critical. Djikstra's - have to consider entire graph from each vertex do a Djikstra run - you'll get shortest paths to all vertices - if the shortest path is reached in 0 (source vertex itself) or 1 hops, it means you're using direct path
69 POLEVAL - Evaluate a polynomial at a point - Use Horner's method. Synthetic division, Polynomial Reminder Theorem
70 DANGER - Josephus problem - have to find nearest two's power - log base 2 of a number is the best way - write down sequence for few iterations, identify pattern kind of problem
71 SUMFOUR - a+b+c+d = 0, 4 lists given. For all pairs a,b check if -(a+b) exists in unordered_map (with reserve keyword) which contains all pairs (c+d)