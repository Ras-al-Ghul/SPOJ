ajay somani's notes on TC
Modular exponentiation and modular multiplication
Concept is quite interesting
modexp - multiply the base by itself, then multiply earlier product with itself, etc. if odd, multiply by base.
modmul - multiply by two, then multiply earlier product with itself
if odd, add in final step.
problems may involve matrix exponentiation - do it on matrix ops now

Some facts on euler's totient function from TC tutorials again
For prime p, for phi(a*p) or phi(a^p), etc.

1 TEST - Test
2 PRIME1 - Primality square root bound - one of the factors to be <= (sqrt N) - two sieves - one up until sqrt(largest number), use this to eliminate numbers within given range which is second sieve - segmented sieve - PRINT is similar which I've done
3 ONP - Reverse Polish Notation - look at complete input file - don't assume things
4 FCTRL - Print trailing zeroes of factorial of number - have to count even numbers and number of multiples of 'powers of 5' - powers of 5 because, eg: 25 - 5*5, one extra 5 - product of these give rise to zeros - since in a given range, number of even numbers is greater than number of 5's, counting the number of 5's is enough - have to look at optimizing logic like that to not get TLE
5 FCTRL2 - Big Integer problem - 100! - the number of digits in a number n is log(n) - number of digits in n! is log(n!) = log(n) + log(n-1) + ... - approximation of factorials are calculated using Stirling's approximation which is not needed here
6 CMPLS - Lagrangian interpolation, Lagrangian polynomials - complete the sequence - method of successive differences, forward differences table this should come to mind when sequence is continuous i.e. for f(i), f(i+1), f(i+2), etc. given in order cannot use if f(i), f(i+5), f(i+x), etc. are given
7 ADDREV - <algorithm> has reverse()
8 TOANDFRO - string ordering and pattern
9 CMEXPR - remove unneeded parantheses - accessing array elements out of bounds need not give segfault - may give random values - use stacks for detecting open brace, close brace - check all input test cases and even more because they might not cover everything - the approach was to consider each brace pair at a time for each brace pair, consider a list of curoperators (bear in mind that there can be more than one) for each brace pair, find the prevoperator and nextoperator if it exists check if the conditions are satisfied for each element in the list of curoperators only then remove the braces - can finish in one pass
10 JULKA - big numbers - take care of variables which are being reused
11 NSTEPS - pattern identification
12 SAMER08F - count squares within squares - sometimes formula might work better than loops - derive formula from loops if possible - if time limit is strict it will be needed
13 FASHION - sort vs. using something like heap - which is better to use - see number of operations and complexity - number of insertions, number of elements, how they will be used, etc.
14 CANDY - nothing touch
15 CANTON - pattern identification
16 COINS - easy dp - find optimal substructure - try catch for bad alloc in dict for dp - if it is full, can't add to dict, have to calculate - also maintain global dict if same dict can be reused for different test cases
17 LASTDIG - last digit of a^b, hence a^b mod 10 which is Modular Exponentiation
18 HANGOVER - floating ops - don't approximate unecessarily - float = 1.0f - look at this problem for floating point comparators
19 PERMUT2 - forgot to use delete[], cost 1 SIGSEGV - SIGABRT caused by problems with memory allocation
20 CANDY3 - simple problems may have huge test cases
21 EIGHTS - find kth number whose cube ends with 888 - find pattern, turns out to be AP - I didn't spot that - cannot increment counter and keep count - will be too slow - hence set digits of answer in an array, directly based on known pattern
22 AE00 - how many rectangles can be formed with unit squares - try to simplify the math even though it may take time this will lead to faster solutions - underflow, subtraction, unsigned numbers
23 ABSYS - string processing
24 AP2 - see if some values can go -ve while using unsigned numbers - d in AP might be negative even if all terms in AP are positive
25 ACODE - single scan DP - number of ways in which string can be decoded - I was considering c[0] <= 2 and c[1] <= 6 what I wanted was c[01] <= 26 for what I was doing, 17 doesn't pass - instead of recursion with function calls for dp, better is single scan left to right dp - look for such methods in string questions - d[i] = d[i-1], if d[i] and d[i-1] < 26, then, d[i] += d[i-2] because d[i-1]d[i] can be read together or one by one - string.erase(index, num of characters to erase)
26 ACPC10A - find if AP or GP, give next number in sequence - if problem is easy, then it is about handling all edge cases
27 STPAR - stacks, parade vehicle ordering
28 BISHOPS - number of non-threatening bishops on 'large' chessboard - identify pattern problem
29 ARMY - Godzilla vs. Mecha - min_heap using pq - priority_queue from <queue>
30 TRICOUNT - Triangle within triangle - count them - oeis.org - enter few terms of series, get formula - which is easier than deriving formula yourself
31 STAMPS - priority_queue - look at how to implement both min_heap and max_heap
32 GUESSING - online game - the actual game is to find an optimal sequence of guesses so that you get to the correct number as soon as possible - at each guess you get some information in return which you can use to formulate next guess - GUESSLNK is tougher - yet to try
33 JAVAC - string transform - java to c++ identifier and vice versa, if none, report error
34 OFFSIDE - detect if player is offside or not - read constraints carefully and direct code 
35 FENCE1 - floating point op - double format specifier is %lf
36 NGM - Turn taking game - integer given on the table - subtract any non zero digit from this number on the table - take turns, whoever writes 0 last wins - initially it looks like DP - best solution of subgame, then best solution within that subgame etc. - but the decrease in size of function at each iteration was not sufficient - hence runs out of stack space for recursing - in the end, Game Theory class example was sufficient - look at what move I make so that his move is forced - basically try to control the game if possible
37 EASYPROB - see pattern and code - had to submit text file with answer
38 EGYPIZZA - find minimum number of pizzas to order so that everyone gets their quantity from one pizza itself - check how to club the given fractions - 1/4, 1/2, 3/4 minimally, and code
39 NEG2 - numbers in base (-2) - look for pattern and code
40 MARBLES - Purely mathematical - bars and stars technique <http://www.mathsisfun.com/combinatorics/combinations-permutations.html> <https://en.wikipedia.org/wiki/Stars_and_bars_%28combinatorics%29> <https://www.statlect.com/mathematical-tools/combinations> <https://stackoverflow.com/questions/15301885/calculate-value-of-n-choose-k> --- look up Pascal triangle - DP method <https://en.wikipedia.org/wiki/Multiset> <https://www.quora.com/How-do-I-divide-a-given-number-into-a-given-number-of-parts-randomly-and-uniformly> - remember what is a multiset, n-1 C k-1 - no zero allowed, n+k-1 C k - with zero allowed formulas - fast way to calculate nCk = (n * (n-1Ck-1))/k - also (n+1 C k) = nCk + nCk-1
41 MAYA - numerical system of the Maya - string processing
42 PIGBANK - bottom up DP - if algo feels wrong - like you feel that there are too many corner cases, then it mostly is wrong - for eg. top down needs too many edge case handling here - also, in memo table for DP, what is chosen as key, what is value, are there duplicate keys possible - in this case it is two coins of same weight, then value should be one with lower value, because problem is about finding minimum amount of money that must be there in piggybank given that it's weight is so much and weights of individual coins are given - top down feels like there are so many possibilites, hence intractable - bottom up approach is, for each weight starting from min value, add the minimum weight coin, or the new coin - new coin may be added only at multiples of it's weight - and only if it reduces the value
43 SBANK - large numbers sort - hence, use map - also keeps track of frequency
44 PIR - volume of pyramid - different formulas were giving different floating point answers - hence many WAs
45 CADYDIST - candy distribution - priority_queue
46 PT07Y - find if graph is tree - iterative DFS - check if you visit a node twice - then graph, else tree - also in neighbours, you will consider all nodes except parent node (node from which you visited the current node) - adjacency list to store graph - DFS approach is as follows - maintain a 'parent' for every node - from current node, after marking it as visited, while adding all neighbours to DFS stack, mark parent of neighbour as current node, unless the neighbour is parent of current node, in that case, mark parent as itself. Also maintain 'visit' field. If you've visited the node earlier and it's value != parent, that means, it is a cycle - because you're visiting the parent from a node other than its child, hence a cycle - note that almost any recursion can be converted to iteration notice that in recursion, the topmost element on the stack gets evaluated first. So if you're looking for an order in which to do iteration, go to the end of the list and come back to front. - can be done with BFS too - also, better than maintaining parent, etc. is to not add parent to DFS stack itself - so if you visit an already visited node, it necessarily means a cycle
47 PARTY - Within budget, find maximum party utility - greedy utility/price ratio does not work - kinda like knapsack - pick current object and decrease so much capacity and recurse or don't pick current object, don't decrease capacity and recurse - take max of both - if both give same utility, choose cheaper cost one
48 PT07Z - length of longest path in tree - double DFS - first DFS gives lower bound - if you're unsure about the approach, don't try to implement, wastes time, because edge cases won't be handled
49 SUMITR - sum of rows - DP - maintain for each column kind - shortcoding
50 UJ - Bigint, hence used Python - n (number of nephews) and d (number of CDs) - n^d ways
51 TWOSQRS - given integer n, decide if possible to represent as sum of two squares of integers - number theory <https://www.quora.com/How-do-I-check-if-a-number-can-be-expressed-as-x-raised-to-power-y> brute force with optimization - precompute all possible squares - do binary search in square space using two pointers method as they are an increasing sequence
52 HUBULLU - predict result of game if both players play optimally - try for n = 1, 2..7, then you'll be clear by then that first player wins no matter what
53 AGGRCOW - Awesome binary search - Assign cows to stalls so that minimum distance between two of them is maximum <https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/> Do a binary search on all possible minimum distances - start = lowest possible minimum distance - end = highest possible minimum distance - for a given distance, see if you can fit cows with that 'mid = (low+high)/2' minimum distance     -     low + (high-low)/2 for handling negative numbers too     -     another important thing is mid = low + (high-low)/2 might be equal to low due to rounding down, in which case, we will get stuck becuase low = mid --> low = low. Therefore if (mid == low), mid = mid + 1, hence ensure that you do not get stuck     -     reqd < ncows vs. reqd <= ncows, where to hand '=' case - in if or in else     -     for deciding low = mid or mid + 1 and high = mid or mid-1, see if mid will still be a part of the solution in next iteration, if yes, then it is = mid, else it is = mid-1 or = mid+1    -    I've used sets to ensure natural sort - also iterators to traverse - #include <iterator> gives prev() and next()
54 CPRMT - Twisted problem statement - just need to print common characters in ascending order - read through the question
55 BEENUMS - find if number is beenum - precompute and store in set - choose most appropriate data structure for fast inserts (in ascending order) and fast lookups
56 LASTDIG2 - modular exponentiation and mulmod - Ajay Somani Topcoder tute
57 GIRLSNBS - Minimum gender regularity - to calculate maximum number of students of same gender that appear together - that means for each boy how many girls, or vice versa, hence simple division with edge cases
58 BYTESM2 - Row Dynamic Programming - choose best choice at each row
59 NSYSTEM - Convert from one system to another and give answer in one system - most important thing in these problems is to minimize the number of conversions and do the required calculation in the simplest system
60 TRT - Treats for cows - DP with 2D grid - dict lookup is costlier than array lookup, hence if 1D/2D array is possible, go for that - also identify what is needed as part of key and what is not, in this case number of days wasn't required as it can be calculated from the number of items between begin and end - read Mimino's articles <https://www.quora.com/Are-there-any-good-resources-or-tutorials-for-dynamic-programming-DP-besides-the-TopCoder-tutorial> <https://www.quora.com/How-do-I-figure-out-how-to-iterate-over-the-parameters-and-write-bottom-up-solutions-to-dynamic-programming-related-problems> - Remember this and the cards problem as canonical examples - Find DP state with only relevant solutions - write a backtrack - recursive, which uses dict lookups preferably - then fill in case by case iterating in a proper order - sometimes it will be max(a1, a2), sometimes it will be max((a1,i)+(i,a2)) for all i between a1, a2 - which means 'for loop' - minimize the number of arguments to the recurse function, these arguments will be the indexes of the 2D grid - DP state should be represented by as few indexes/variables as possible - for eg. 1152, 1352, etc. can be DP states or 1...2, can encode both of them - longest common subsequence also in Mimino's answer
61 BEADS - Suffix array can be used <http://www.geeksforgeeks.org/suffix-array-set-1-introduction/> - also simple construct all strings of length n, sort, give answer can be used - I think I did consider only strings starting with smallest character, form substrings of length n from them and sort - even length n is not required, less than that, till wherever required is better
62 LABYR1 - another double DFS - challenging implementation
63 MIXTURES - variation of a problem from second Mimino's answer link question - the problem with just the above is some combinations are not considered for example, for {a,b,c,d}, the above considers (abc)(d) = (ab)(c)(d) and (a)(bc)(d) AND (a)(bcd) = (a)(bc)(d) and (a)(b)(cd) but it does not cover (ab)(cd) have to account for this similar for {a,b,c,d,e} luckily this can be done in one loop - the while(count) loop
64 BITMAP - a grid of 0's and 1's - find nearest 1 for each 0 - write that distance in that location - my approach - for each 1, go as far as possible - i.e. while it improves distance - stop if it doesn't - do not go further on a path if you don't improve the minimum distance - that means in first iteration, you will go on all paths reachable from that 1 because initial distance to each 0 reachable from that 1 would be initialized to INT_MAX
65 WORDS1 - <https://www.quora.com/How-do-I-solve-the-SPOJ-Play-on-Words-problem> - this should suffice - the first thing to look at is what is edge and what is vertex, 'consider both cases' and pick appropriately - here if end points of words are vertices, like for 'dance' de is a vertex, then it becomes a complex directed graph which will not be tractable and solved using simple conditions - here, only after we decide edges connect starting and ending letter, are we able to see that it is Euler path problem - see if you can use adjacency matrix if domain size is small - here all possible alphabets - 26*26 - in this case vertices are both end letters and edges connect starting and ending letters of word since we need to use all words, it means, find Euler path - path which uses all the edges - store incoming and outgoing vertices too - if all vertices have equal indegree and outdegree, then their overall degree (in degree + out degree for each vertex) is even or mod difference is zero - if exactly two vertices have outdegree - indegree = 1 and indegree - outdegree = 1, then one is start and the other is end - if not above two cases, then not possible to find Euler path - and for above two cases, check for connected graph using DFS - and choose start vertex for this DFS properly - in case of all even degrees, choose anyone with outdegree > 0 - in case of at most two odd degree, choose one with outdegree - indegree = 1 - also, for DFS, once you visit a node - i.e. a row index, for each j (column), make its entry 0 and add to DFS stack - no need to decrement count one by one - this can occur when words like dance, drive, etc. occur - same starting and ending letter, hence for i=d, j=e will be 2 - we don't need to traverse, we're just trying to see what vertices are reachable from start vertex
66 ARITH2 - simple calculations
67 PERMUT1 - <http://www.algorithmist.com/index.php/SPOJ_PERMUT1> - quite complex reasoning exists - but what I did was - look at constraint that n (1<=n<=12) and k (0<=k<=98) - hence 2D array dp - construct manually for n = 1, 2, 3 and 4 to see how to come up with solution - add existing inversions to previous inversions
68 ROADNET - graph with shortest path between two nodes given, find if two towns are neighours - this happens when there is no third town such that a path through it is shorter than direct shortest path which is given - Djikstra's algo - O(N^3) method maybe faster. Update of hops is critical. Djikstra's - have to consider entire graph from each vertex do a Djikstra run - you'll get shortest paths to all vertices - if the shortest path is reached in 0 (source vertex itself) or 1 hops, it means you're using direct path
69 POLEVAL - Evaluate a polynomial at a point - Use Horner's method. Synthetic division, Polynomial Reminder Theorem
70 DANGER - Josephus problem - have to find nearest two's power - log base 2 of a number is the best way - write down sequence for few iterations, identify pattern kind of problem
71 SUMFOUR - a+b+c+d = 0, 4 lists given. For all pairs a,b check if -(a+b) exists in unordered_map (with reserve keyword) which contains all pairs (c+d)
72 CHOCOLA - greedy - every vertical/horizontal cut has a cost, choose ordering of cuts so that cost is minimized - how to choose greedy vs. DP - most important, in choice betw. DP and greedy, see if greedy works in a DP problem try to come up with counter example that it doesn't - optimal substructure is key - because total number of cuts we need to make is same in whole problem we can change costs by ordering the costlier ones first - only across row and column - row after row or col after col makes no difference - when you apply costlier cut first, you ensure it is applied on less number of pieces - remove specific key,value from multimap <https://stackoverflow.com/questions/3952476/how-to-remove-a-specific-pair-from-a-c-multimap>
73 GSS1 - Range query - maximum sum subarray - Kadane is too slow - Hence Segment Trees - <https://www.youtube.com/watch?v=ZBHKZF5w4YU> <https://www.quora.com/What-is-the-approach-for-solving-GSS1-and-GSS3-on-SPOJ-using-segment-trees> - here querying also requires creation of nodes on the fly - updation of the four values - totalsum, maxnonemptyprefix, maxnonemptysuffix, maxnonemptysum is critical - (sizeof(inputarr)/sizeof(*inputarr)) is slick - One can be done in O(n), other in O(1), What if the number of query and updates are equal? Can we perform both the operations in O(log n) time once given the array? We can use a Segment Tree to do both operations in O(log n) time. - lazy propagation - update only when necessary - for range update, store tobeupdated number in lazy array which is same size as storage array, check that array before doing any 'getting information' operation
74 MINCOUNT - count number of moves required to invert triangle - found sequence on OEIS - important thing is to solve first few cases of the sequence properly
75 NY10A - count number of HHH, HTH, ... in a sequence of 40 tosses - maintain three strings, update, handling case by case - generalizing might be the real deal - does product DFA/NFA apply here?
76 QUADAREA - given 4 sides of quadrilateral such that sum of three is greater than the fourth, what is maximal area? - <https://math.stackexchange.com/questions/266783/geometric-argument-as-to-why-the-cyclic-quadrilateral-has-the-maximal-area> - <https://www.quora.com/Sphere-Online-Judge-SPOJ-In-the-problem-QUADAREA-why-does-my-program-give-a-wrong-answer-if-I-use-floats-but-a-correct-one-if-I-use-doubles>
77 CHICAGO - find path with highest probability of not getting caught - inverse of Djikstra - remember that Djikstra is about shortest distance from source to points not in the circle - it is not shortest distance from any point in current boundary to points not in the circle - also, in Djikstra, printing path means, store 'parent array' - instead of trying to update priority_queue, add everything to pq, but ignore visited <https://stackoverflow.com/questions/9209323/easiest-way-of-using-min-priority-queue-with-key-update-in-c>
78 MAXLN - Find max value of AB^2 + BC - Thales theorem, AB^2 + BC^2 = (2r)^2, because right angled - differentiate and find value - sometimes differentiate gives minima - have to reformulate optimization objective
79 WORDCNT - count number of words in longest continuous sequence of same length words - string handling and edge case handling - reading space separated strings - sstream
80 MFLAR10 - tell if tautogram or not - sentences with all words beginning with same case-insensitive letter
81 HPYNOS - sum of squares of digits - Happy Number if it sums to 1 - if it repeats in cycle, then not - upper bounding is important
82 AIBOHP - DP - find least number of characters to insert to make input string a palindrome - fill along diagonals, base case - 1 char at a time, 2 chars at a time - bottom up DP - two cases - depends on (i+1,column-1) or min((i,col-1),(i+1,col)) - first case if first and last equal, second if first != last - notice that proper separation - disjoint union ensures that locks are not needed - look at cpp for more details - alt is to use {strlen - LCS(str, revstr)} formula
83 AMR10G - find minimum difference between k heights out of given n - simple sort and maintain best so far - std::sort is quicker than qsort
84 HASHIT - straightforward hashing
85 FAVDICE - Coupon collector problem - remember approach - math
86 ACS - array operations - do row/column interchange and querying in O(n) time and complete array won't fit in memory - use arr[nrows] and arc[ncols] to keep track - you will need two more arrays to make everything O(1)
87 WILLITST - workout pattern till num=10 and then do - if power of 2, then stops, else no
88 SHPATH - textbook Djikstra - stop as soon as you hit destination node - again no need to update values in heap, just keep adding
89 SHOP - find shortest path in grid - modified Djikstra - no need to try to construct graph, instead directly use Djikstra on vertices - can also use BFS - in Djikstra's, see if you can stop after reaching destination vertex
90 ETF - Euler Totient Function - direct formula uses float ops, hence use modified method - <http://www.geeksforgeeks.org/eulers-totient-function/>
91 MRECAMAN - brute force sequence
92 ASSIST - find n th lucky number - like Josephus problem - sieve used for other purposes
93 TRGRID - traversing a grid - generating and classifying into cases is the key - reduce the grid to a small size after full traversals - in reduced grid size, dimensions can be (1,1), (1,2), (2,1), (2,2), ((1,2),other), (other,(1,2)) - now handle case by case - <http://xoptutorials.com/index.php/2017/01/01/spojtrgrid/>
94 ANARC05B - find maximum sum in two strictly increasing strings - can switch between strings at intersections (indices with same number) - linear DP - O(n+m) solution
95 ANARC09A - match the braces - DP was very slow, but perfectly working - had to use stack - couldn't really use 'only even number of {}'s' condition - other interesting O(n^2) DP solution <https://abitofcs.blogspot.in/2014/10/a-bit-of-string-balancing-spoj-anarc09a.html> - If you can't solve with grid method, try Mimino's classical approach and handle all cases - main thing is to recognize DP state - don't get caught up with the idea that two indices of string is the only possible state - in above link it was (index, number of open braces) - then look at current index and see what cases are possible
96 BASE - convert number from one base system to another system - interesting way to convert a base 10 number to any base - mod by base to get last digit in new base system, divide by base to reduce to new number and repeat
97 EBOXES - find total number of boxes on the table - create equation and solve
98 EDIST - find minimum number of insertions/deletions/replace needed to make two strings the same - 2D grid DP - sometimes initialization may need to be done in a custom fashion - after base case is properly handled, everything will fall into place
99 BYECAKES - find least amount of ingredients to buy to make minimum integer number of cakes - kinda greedy - ratio approach - lot of edge cases - 0 0 0 0 2 3 4 5 was one hell of an edge case
100 INVCNT - calculate inversion count in given array - standard merge sort based solution and also Fenwick tree based solution (Binary Indexed Tree BIT) - look at problem file for details - key steps - normalizing data while maintaing order, processing from back to front to convert into Fenwick tree --> calculate prefix sum of index and update by adding 1 at that index problem - <https://notes.tweakblogs.net/blog/9835/fenwick-trees-demystified.html> for beautiful Fenwick tree explanation - no need of extra 0 for root in Fenwick tree - both Prefix sum and update in O(logn) without extra space - also read about bitmask since it was one of the tags - used in set enumeration problems - TSP using bitmask, N person, N task assignment problem - both can be done using bitmasks - see file for more info - see constraint on n - if it is less, that means, all sets can be enumerated --> bitmask - see 126 ASSIGN
101 CUBES - find all a^3 = b^3 + c^3 + d^3 where a>1, a<=100, brute force - dict and set problem - whenever brute force, think about dict/set
102 CSTREET - MST - used Kruskal's - Be careful in getparent - at the end, in line 44 - you have to change set of parent, not set of current - can also reset parents of all indices during traversal to actual parent, speeds up further getparents - Prim's - For Prim's, maintain visited list/set and cost list - both over vertices - cost list maintains cost of all edges in the cut - choose min of that i.e. cost of reaching vertices part of cut, but outside visited, from vertices part of cut, but already visited - initialize cost list to infinity, and on adding an edge to visited, update cost of all vertices which become a part of the cut
103 TOE1 - find if given state is valid position in a tic tac toe game or not - consider edge cases - read question that x always starts first
104 ABCDEF - find all possible sextuples - three on LHS, three on RHS in sorted array - binary search - brute force - map is not always good - when multiple inserts - better to sort at once - distance(it1, it2) from std::iterator gives number of elements between it1 and it2
105 HISTOGRA - calculate area of largest rectangle in a histogram - all nearest smaller values problem - stack based solution - D&C - using segment tree - O(n) vs. O(nlogn) - see problem file for more details - segment tree --> RMQ - range minimum query - important thing here is to understand why these are working - for stack based soln, one of the answers on Quora had an explanation on flipping the constraints  - like dual of LP - for any pair of indices i,j, maxarea(i,j) is constrained by min(i,j) - flip to find that for each index given height, till where can you extend boundaries - to left - to right - hence stack based - also can we manage in one pass? - D&C is easier to understand, again in a given range, find min - it extends till end of range on left and right side - recurse in left part and right part from given index - why does it work? you will consider height of all indices and stretch it to maximum possible on both left and right - hence all cases are considered - converting it to RMQ problem is the key step - min(i,j) is the key
106 PPATH - find smallest number of 'one digit at a time' changes from one 4 digit prime to another 4 digit prime both of which are given - sieve, create graph of primes, BFS
107 GLJIVE - Find cumulative sum starting from index 0, closest to 100 - cryptic way of stating the question
108 POUR1 - GCD, recursion - find minimum number of moves to make 'c' using containers 'a' and 'b' - pour, empty, transfer - linear diophantine equation - ax+by=c iff c % gcd(a,b) = 0 - other way to discuss feasibility is to look for cycles - see problem cpp - notice the 'difference' method of calculating GCD - keeping on subtracting the smaller number from bigger number, GCD won't change, but you will end up at the GCD - can solve using BFS also - see problem cpp - remember to check other way around, if possible - for example here there were two ways, pour from a to b OR pour from b to a - I did not consider both possibilities - Diophantine equations are important when a problem requires a solution in whole amounts - using only container 'a' and container 'b' - see if you can cast as Diophantine problem
109 ANARC09B - Find smallest number of rectangles to use to form a square - orientation of the tiles is to be the same - spoj toolkit was wrong - lcm/gcd
110 NOTATRI - given a series of numbers, find number of ways of picking three numbers from the sequence such that they don't form a triangle - binary search - sort - order doesn't matter, only combinations, not permutations - for every pair, find index of element with value > sum(a+b), everything to the right and this included, cannot form triangle - edge case - find leftmost such index
111 OLOLO - given a sequence of numbers, all numbers appear twice, except one - find that number - bitwise xor ^ operator - if 'twice'/'even number of times' occurs, think of using xor
112 STREETR - given sequence of trees, find minimum number that must be planted, so that distance between any two adjacent trees will be minimum - eg. 1 3 7 13 - 3 trees at 5, 9 and 11 - I did O(minDist*n) scan which is slow - better is to find gcd of distances - gcd n numbers - sort and find for each pair - gcd can only decrease - gcd(smallest two nos.) is best upper bound
113 PHONELST - given phone numbers, say if they are prefix free - trie based solution - related to huffman coding
114 ROOTCIPH - given a,b,c in x^3+ax^2+bx+c, the roots of which are the relative coordinates of plane, find square of distance - <http://codeinblood.blogspot.in/2017/01/decipher-spoj-problem-solution.html> - <http://forums.xkcd.com/viewtopic.php?t=15382> - sum of roots, product of roots - relation of them with coefficients of the polynomial
115 BLINNET - Kruskal's - borrowed template from earlier Kruskal's code - changed getparent to point to which set it belongs to using recursion - optimized for dist a-b = dist b-a, hence ignore later edges
116 PQUEUE - printer prints jobs according to priority - 6 0 - 6 jobs, 0th is mine - 1 1 9 1 1 1 - first job taken from queue, if highest priority print, else push to 'end of' queue, hence in this case time taken is 5 seconds - so maintain two priority queues - one for actual priority, other for indices - similar to two stack approach in some other problems - custom comparator for priority queue
117 SILVER - Given a rod of length n, divide it into minimum number of parts such that you can generate a rod of each length from 1 to number n. For given n, 2^m<= n < 2^(m+1) , number of cuts will be m and hence numbers of parts will be m+1. In present case n=7 lies in the range [4,8), so number of cuts(divide/break) = 2 - think of it as binary number representation - 0 - you don't give, 1 you give - least number of bits needed to represent a number - brilliant
118 PON - Prime or not - Implement Primality test - Miller Rabin from Cryptographic_Musings repo - no need of perfect powers test - C++ may give overflow, hence use unsigned long long
119 CLONE - given a set of strings, count number of occurences of each - dict solution
120 LENGFACT - length of n! - <https://www.geeksforgeeks.org/count-digits-factorial-set-2/> - formula based - Kamenetsky's formula
121 CRSCNTRY - cryptic problem statement - turned out to be vanilla Longest Common Subsequence - LCS - bottom up DP - important to decipher problem statement - read problem statement for this on SPOJ
122 MKLABELS - find number of possible labeled trees for given n where n is number of nodes - pattern can be found pow(n, n-2) - OEIS can also be used <http://oeis.org/search?q=1%2C3%2C16%2C125&language=english&go=Search>
123 ROCK - find total length of rock that can be sold after breaking up the rock in the best possible way - sweet to be greater than sour - eg. for 100110001010001 - 10011 101 1 = 5+3+1 = 9 length - two ways to solve this - Matrix Chain Multiplication MCX - all possible combinations of k - which is what I did - O(n^3) - <https://www.quora.com/How-do-I-solve-the-sweet-and-sour-rock-program-in-SPOJ> - the other is using just one array dp - very elegant - <http://artofcompetitiveprogramming.blogspot.in/2016/01/spoj-sweet-and-sour-rock.html> <https://github.com/georgejsh/codeandsolutions/blob/master/rock.c> - here - so the problem b[i] can be solved as b[i] =max( b[i-1]  , b[j-1] + i-j+1)  for each j where the segment from j to i has more sweet rock than sour (j<i)
124 BINSTIRL - <https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind> - find parity - i.e. ans%2
125 SQRBR - What is the number of proper bracket expressions (num open = num close and valid) in length 2n, given that you need '{' compulsarily at s1<s2<s3..<sk positions - DP - bottom up - do not get stuck up with grid where i,j mean indices of string - it may be grid where i,j mean something else - here let count(i,j) be the number of valid ways of filling the first i positions such that there are j more brackets of type '{' than of type '}' - count(0,1) = 1, build from there - count(0,i) = 0 for i>1 - recurrence for i>0 is count(i,0) = count(i-1,1), count(i,j) = count(i-1,j-1) + count(i-1,j+1) for j>0 - but if you have to enforce '{' at position i, then, count(i,0) = 0 and count(i,j) = count(i-1,j-1) for j>0 - I was stuck up with grid index thinking - if it is too hard to formulate, then it means, grid string index meaning of the problem is wrong way to think about it, move on to try to find another dp state - one of them will most likely still be index of string, but the other variable in the state may mean something else - <https://www.quora.com/How-to-solve-square-brackets-problem-on-SPOJ-SPOJ-SQRBR> - notice that we get answer at count(2n, 0) - subproblems are disjoint - i.e. count(i-1, j-1) and count(i-1, j+1) don't enumerate the same cases and hence can be just summed over like we don't want AUB = A+B-(AXnB) - index 'i' is monotonically increasing, so fill row wise - very important to get right DP state - (index, number of valid ways '{' j more than '}')
126 ASSIGN - given n classes, n student preferences, assign 1 student to 1 class within given student preferences - find number of ways to do this - start with backtrack (systematic way to brute force) - because we need faster, use DP with two states (mask, i) and bitmask - mask indicates which students have been allocated, i indicates classes 0 to i-1 have been dealt with - countways(mask, i) = countways(mask, i+1) + sum(countways(mask|(1<<j), i+1) for each j which can do task i) - but i can be calculated as sum of set bits in mask as we cannot do countways(mask, i+1) i.e. move on without assigning because we need 1-1 map - hence dp state depends on just mask - we need bottom up DP - derive it from above top down DP - notice order which they have to be filled - reverse order - <https://www.hackerearth.com/practice/algorithms/dynamic-programming/bit-masking/tutorial/> - <http://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/> - see code file - see 100 INVCNT - intuition for DP comes from backtrack solution in this case - remember a few canonical DP states - TSP, assignment problem - in TSP, we need two variables for state because relative ordering also matters - also min(ans, newans) vs. sum()
127 BABTWR - a,b,c - three dimensions of box given, you can rotate however you want, any number of boxes of given dimension are available, what is tallest stack of boxes you can build given that you can only stack one box on another if both of the non-height dimensions are lesser than the one on top of which you're stacking -related to Longest Increasing subsequence and box stacking problem - <https://www.geeksforgeeks.org/longest-increasing-subsequence/> - <http://code.cloudkaksha.org/algorithm/dynamic-programming/box-stacking-problem> - exploit sorted order, also be very careful on what to do with the values if duplicate keys can exist for a dict
128 GSS3 - GSS1 + update - for update, just set the leaf node appropriately and update upper nodes, lazy propagation is harder to implement
129 TOE2 - find out if valid end position of TicTacToe game or not - same as TOE1 except 1 case - draw - only when board is full - interesting <https://stackoverflow.com/questions/7466429/generate-a-list-of-all-unique-tic-tac-toe-boards>
